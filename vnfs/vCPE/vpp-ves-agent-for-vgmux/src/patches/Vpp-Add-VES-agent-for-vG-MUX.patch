From 3d16acbb7942682864fd9b8ca9ca15e4147325f1 Mon Sep 17 00:00:00 2001
From: Johnson Li <johnson.li@intel.com>
Date: Fri, 22 Sep 2017 08:58:40 +0800
Subject: [PATCH] Add VES Agent to report statistics

Change Log:
v2: Use VES 5.x as agent library
v1: Add VES agent to report statistics

Signed-off-by: Johnson Li <johnson.li@intel.com>

diff --git a/src/configure.ac b/src/configure.ac
index fb2ead6d..ea641525 100644
--- a/src/configure.ac
+++ b/src/configure.ac
@@ -154,6 +154,7 @@ PLUGIN_ENABLED(lb)
 PLUGIN_ENABLED(memif)
 PLUGIN_ENABLED(sixrd)
 PLUGIN_ENABLED(snat)
+PLUGIN_ENABLED(ves)
 
 ###############################################################################
 # Dependency checks
diff --git a/src/plugins/Makefile.am b/src/plugins/Makefile.am
index 623892e7..84513755 100644
--- a/src/plugins/Makefile.am
+++ b/src/plugins/Makefile.am
@@ -69,6 +69,10 @@ if ENABLE_SNAT_PLUGIN
 include snat.am
 endif
 
+if ENABLE_VES_PLUGIN
+include ves.am
+endif
+
 include ../suffix-rules.mk
 
 # Remove *.la files
diff --git a/src/plugins/ves.am b/src/plugins/ves.am
new file mode 100644
index 00000000..10f2194b
--- /dev/null
+++ b/src/plugins/ves.am
@@ -0,0 +1,35 @@
+# Copyright (c) <current-year> <your-organization>
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at:
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+vppplugins_LTLIBRARIES += ves_plugin.la
+
+LIBS_DIR=$(CURDIR)/ves/libs
+ves_plugin_la_LDFLAGS = $(AM_LDFLAGS) -L$(LIBS_DIR)
+ves_plugin_la_LDFLAGS += -Wl,--whole-archive -level -Wl,--no-whole-archive
+ves_plugin_la_LDFLAGS += -Wl,-lpthread,-lcurl
+
+ves_plugin_la_SOURCES = ves/ves_node.c  \
+  ves/ves_api.c
+
+BUILT_SOURCES +=			\
+  ves/ves.api.h				\
+  ves/ves.api.json
+
+API_FILES += ves/ves.api
+
+nobase_apiinclude_HEADERS +=		\
+  ves/ves_all_api_h.h			\
+  ves/ves_msg_enum.h			\
+  ves/ves.api.h
+
+# vi:syntax=automake
diff --git a/src/plugins/ves/include/double_list.h b/src/plugins/ves/include/double_list.h
new file mode 100644
index 00000000..5cf7e1af
--- /dev/null
+++ b/src/plugins/ves/include/double_list.h
@@ -0,0 +1,57 @@
+/*************************************************************************//**
+ *
+ * Copyright © 2017 AT&T Intellectual Property. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+/**************************************************************************//**
+ * @file
+ * A simple double-linked list.
+ *
+ * @note  No thread protection so you will need to use appropriate
+ * synchronization if use spans multiple threads.
+ *
+ ****************************************************************************/
+
+#ifndef DOUBLE_LIST_INCLUDED
+#define DOUBLE_LIST_INCLUDED
+
+typedef struct dlist_item
+{
+  struct dlist_item * previous;
+  struct dlist_item * next;
+  void * item;
+} DLIST_ITEM;
+
+/**************************************************************************//**
+ * Double-linked list structure
+ *****************************************************************************/
+typedef struct dlist
+{
+  DLIST_ITEM * head;
+  DLIST_ITEM * tail;
+} DLIST;
+
+
+void dlist_initialize(DLIST * list);
+void * dlist_pop_last(DLIST * list);
+void dlist_push_first(DLIST * list, void * item);
+void dlist_push_last(DLIST * list, void * item);
+DLIST_ITEM * dlist_get_first(DLIST * list);
+DLIST_ITEM * dlist_get_last(DLIST * list);
+DLIST_ITEM * dlist_get_next(DLIST_ITEM * item);
+int dlist_is_empty(DLIST * list);
+int dlist_count(DLIST * list);
+
+#endif
diff --git a/src/plugins/ves/include/evel.h b/src/plugins/ves/include/evel.h
new file mode 100644
index 00000000..6aceec30
--- /dev/null
+++ b/src/plugins/ves/include/evel.h
@@ -0,0 +1,4494 @@
+#ifndef EVEL_INCLUDED
+#define EVEL_INCLUDED
+/*************************************************************************//**
+ *
+ * Copyright © 2017 AT&T Intellectual Property. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+/**************************************************************************//**
+ * @file
+ * Header for EVEL library
+ *
+ * This file implements the EVEL library which is intended to provide a
+ * simple wrapper around the complexity of AT&T's Vendor Event Listener API so
+ * that VNFs can use it without worrying about details of the API transport.
+ *
+ * Zero return value is success (::EVEL_SUCCESS), non-zero is failure and will
+ * be one of ::EVEL_ERR_CODES.
+ *****************************************************************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <time.h>
+
+#include "jsmn.h"
+#include "double_list.h"
+#include "hashtable.h"
+
+/*****************************************************************************/
+/* Supported API version.                                                    */
+/*****************************************************************************/
+#define EVEL_API_MAJOR_VERSION 5
+#define EVEL_API_MINOR_VERSION 0
+
+/**************************************************************************//**
+ * Error codes
+ *
+ * Error codes for EVEL low level interface
+ *****************************************************************************/
+typedef enum {
+  EVEL_SUCCESS,                   /** The operation was successful.          */
+  EVEL_ERR_GEN_FAIL,              /** Non-specific failure.                  */
+  EVEL_CURL_LIBRARY_FAIL,         /** A cURL library operation failed.       */
+  EVEL_PTHREAD_LIBRARY_FAIL,      /** A Posix threads operation failed.      */
+  EVEL_OUT_OF_MEMORY,             /** A memory allocation failure occurred.  */
+  EVEL_EVENT_BUFFER_FULL,         /** Too many events in the ring-buffer.    */
+  EVEL_EVENT_HANDLER_INACTIVE,    /** Attempt to raise event when inactive.  */
+  EVEL_NO_METADATA,               /** Failed to retrieve OpenStack metadata. */
+  EVEL_BAD_METADATA,              /** OpenStack metadata invalid format.     */
+  EVEL_BAD_JSON_FORMAT,           /** JSON failed to parse correctly.        */
+  EVEL_JSON_KEY_NOT_FOUND,        /** Failed to find the specified JSON key. */
+  EVEL_MAX_ERROR_CODES            /** Maximum number of valid error codes.   */
+} EVEL_ERR_CODES;
+
+/**************************************************************************//**
+ * Logging levels
+ *
+ * Variable levels of verbosity in the logging functions.
+ *****************************************************************************/
+typedef enum {
+  EVEL_LOG_MIN               = 0,
+  EVEL_LOG_SPAMMY            = 30,
+  EVEL_LOG_DEBUG             = 40,
+  EVEL_LOG_INFO              = 50,
+  EVEL_LOG_ERROR             = 60,
+  EVEL_LOG_MAX               = 101
+} EVEL_LOG_LEVELS;
+
+/*****************************************************************************/
+/* Maximum string lengths.                                                   */
+/*****************************************************************************/
+#define EVEL_MAX_STRING_LEN          4096
+#define EVEL_MAX_JSON_BODY           16000
+#define EVEL_MAX_ERROR_STRING_LEN    255
+#define EVEL_MAX_URL_LEN             511
+
+/**************************************************************************//**
+ * This value represents there being no restriction on the reporting interval.
+ *****************************************************************************/
+static const int EVEL_MEASUREMENT_INTERVAL_UKNOWN = 0;
+
+/**************************************************************************//**
+ * How many events can be backed-up before we start dropping events on the
+ * floor.
+ *
+ * @note  This value should be tuned in accordance with expected burstiness of
+ *        the event load and the expected response time of the ECOMP event
+ *        listener so that the probability of the buffer filling is suitably
+ *        low.
+ *****************************************************************************/
+static const int EVEL_EVENT_BUFFER_DEPTH = 100;
+
+/*****************************************************************************/
+/* How many different IP Types-of-Service are supported.                     */
+/*****************************************************************************/
+#define EVEL_TOS_SUPPORTED      256
+
+/**************************************************************************//**
+ * Event domains for the various events we support.
+ * JSON equivalent field: domain
+ *****************************************************************************/
+typedef enum {
+  EVEL_DOMAIN_INTERNAL,       /** Internal event, not for external routing.  */
+  EVEL_DOMAIN_HEARTBEAT,      /** A Heartbeat event (event header only).     */
+  EVEL_DOMAIN_FAULT,          /** A Fault event.                             */
+  EVEL_DOMAIN_MEASUREMENT,    /** A Measurement for VF Scaling event.        */
+  EVEL_DOMAIN_MOBILE_FLOW,    /** A Mobile Flow event.                       */
+  EVEL_DOMAIN_REPORT,         /** A Measurement for VF Reporting event.      */
+  EVEL_DOMAIN_HEARTBEAT_FIELD,/** A Heartbeat field event.                   */
+  EVEL_DOMAIN_SIPSIGNALING,   /** A Signaling event.                         */
+  EVEL_DOMAIN_STATE_CHANGE,   /** A State Change event.                      */
+  EVEL_DOMAIN_SYSLOG,         /** A Syslog event.                            */
+  EVEL_DOMAIN_OTHER,          /** Another event.                             */
+  EVEL_DOMAIN_THRESHOLD_CROSS,  /** A Threshold Crossing  Event		     */
+  EVEL_DOMAIN_VOICE_QUALITY,  /** A Voice Quality Event		 	     */
+  EVEL_MAX_DOMAINS            /** Maximum number of recognized Event types.  */
+} EVEL_EVENT_DOMAINS;
+
+/**************************************************************************//**
+ * Event priorities.
+ * JSON equivalent field: priority
+ *****************************************************************************/
+typedef enum {
+  EVEL_PRIORITY_HIGH,
+  EVEL_PRIORITY_MEDIUM,
+  EVEL_PRIORITY_NORMAL,
+  EVEL_PRIORITY_LOW,
+  EVEL_MAX_PRIORITIES
+} EVEL_EVENT_PRIORITIES;
+
+/**************************************************************************//**
+ * Fault / Threshold severities.
+ * JSON equivalent field: eventSeverity
+ *****************************************************************************/
+typedef enum {
+  EVEL_SEVERITY_CRITICAL,
+  EVEL_SEVERITY_MAJOR,
+  EVEL_SEVERITY_MINOR,
+  EVEL_SEVERITY_WARNING,
+  EVEL_SEVERITY_NORMAL,
+  EVEL_MAX_SEVERITIES
+} EVEL_SEVERITIES;
+
+/**************************************************************************//**
+ * Fault source types.
+ * JSON equivalent field: eventSourceType
+ *****************************************************************************/
+typedef enum {
+  EVEL_SOURCE_OTHER,
+  EVEL_SOURCE_ROUTER,
+  EVEL_SOURCE_SWITCH,
+  EVEL_SOURCE_HOST,
+  EVEL_SOURCE_CARD,
+  EVEL_SOURCE_PORT,
+  EVEL_SOURCE_SLOT_THRESHOLD,
+  EVEL_SOURCE_PORT_THRESHOLD,
+  EVEL_SOURCE_VIRTUAL_MACHINE,
+  EVEL_SOURCE_VIRTUAL_NETWORK_FUNCTION,
+  /***************************************************************************/
+  /* START OF VENDOR-SPECIFIC VALUES                                         */
+  /*                                                                         */
+  /* Vendor-specific values should be added here, and handled appropriately  */
+  /* in evel_event.c.                                                        */
+  /***************************************************************************/
+
+  /***************************************************************************/
+  /* END OF VENDOR-SPECIFIC VALUES                                           */
+  /***************************************************************************/
+  EVEL_MAX_SOURCE_TYPES
+} EVEL_SOURCE_TYPES;
+
+/**************************************************************************//**
+ * Fault VNF Status.
+ * JSON equivalent field: vfStatus
+ *****************************************************************************/
+typedef enum {
+  EVEL_VF_STATUS_ACTIVE,
+  EVEL_VF_STATUS_IDLE,
+  EVEL_VF_STATUS_PREP_TERMINATE,
+  EVEL_VF_STATUS_READY_TERMINATE,
+  EVEL_VF_STATUS_REQ_TERMINATE,
+  EVEL_MAX_VF_STATUSES
+} EVEL_VF_STATUSES;
+
+/**************************************************************************//**
+ * Counter criticalities.
+ * JSON equivalent field: criticality
+ *****************************************************************************/
+typedef enum {
+  EVEL_COUNTER_CRITICALITY_CRIT,
+  EVEL_COUNTER_CRITICALITY_MAJ,
+  EVEL_MAX_COUNTER_CRITICALITIES
+} EVEL_COUNTER_CRITICALITIES;
+
+/**************************************************************************//**
+ * Alert actions.
+ * JSON equivalent field: alertAction
+ *****************************************************************************/
+typedef enum {
+  EVEL_ALERT_ACTION_CLEAR,
+  EVEL_ALERT_ACTION_CONT,
+  EVEL_ALERT_ACTION_SET,
+  EVEL_MAX_ALERT_ACTIONS
+} EVEL_ALERT_ACTIONS;
+
+/**************************************************************************//**
+ * Alert types.
+ * JSON equivalent field: alertType
+ *****************************************************************************/
+typedef enum {
+  EVEL_ALERT_TYPE_CARD,
+  EVEL_ALERT_TYPE_ELEMENT,
+  EVEL_ALERT_TYPE_INTERFACE,
+  EVEL_ALERT_TYPE_SERVICE,
+  EVEL_MAX_ALERT_TYPES
+} EVEL_ALERT_TYPES;
+
+/**************************************************************************//**
+ * Alert types.
+ * JSON equivalent fields: newState, oldState
+ *****************************************************************************/
+typedef enum {
+  EVEL_ENTITY_STATE_IN_SERVICE,
+  EVEL_ENTITY_STATE_MAINTENANCE,
+  EVEL_ENTITY_STATE_OUT_OF_SERVICE,
+  EVEL_MAX_ENTITY_STATES
+} EVEL_ENTITY_STATE;
+
+/**************************************************************************//**
+ * Syslog facilities.
+ * JSON equivalent field: syslogFacility
+ *****************************************************************************/
+typedef enum {
+  EVEL_SYSLOG_FACILITY_KERNEL,
+  EVEL_SYSLOG_FACILITY_USER,
+  EVEL_SYSLOG_FACILITY_MAIL,
+  EVEL_SYSLOG_FACILITY_SYSTEM_DAEMON,
+  EVEL_SYSLOG_FACILITY_SECURITY_AUTH,
+  EVEL_SYSLOG_FACILITY_INTERNAL,
+  EVEL_SYSLOG_FACILITY_LINE_PRINTER,
+  EVEL_SYSLOG_FACILITY_NETWORK_NEWS,
+  EVEL_SYSLOG_FACILITY_UUCP,
+  EVEL_SYSLOG_FACILITY_CLOCK_DAEMON,
+  EVEL_SYSLOG_FACILITY_SECURITY_AUTH2,
+  EVEL_SYSLOG_FACILITY_FTP_DAEMON,
+  EVEL_SYSLOG_FACILITY_NTP,
+  EVEL_SYSLOG_FACILITY_LOG_AUDIT,
+  EVEL_SYSLOG_FACILITY_LOG_ALERT,
+  EVEL_SYSLOG_FACILITY_CLOCK_DAEMON2,
+  EVEL_SYSLOG_FACILITY_LOCAL0,
+  EVEL_SYSLOG_FACILITY_LOCAL1,
+  EVEL_SYSLOG_FACILITY_LOCAL2,
+  EVEL_SYSLOG_FACILITY_LOCAL3,
+  EVEL_SYSLOG_FACILITY_LOCAL4,
+  EVEL_SYSLOG_FACILITY_LOCAL5,
+  EVEL_SYSLOG_FACILITY_LOCAL6,
+  EVEL_SYSLOG_FACILITY_LOCAL7,
+  EVEL_MAX_SYSLOG_FACILITIES
+} EVEL_SYSLOG_FACILITIES;
+
+/**************************************************************************//**
+ * TCP flags.
+ * JSON equivalent fields: tcpFlagCountList, tcpFlagList
+ *****************************************************************************/
+typedef enum {
+  EVEL_TCP_NS,
+  EVEL_TCP_CWR,
+  EVEL_TCP_ECE,
+  EVEL_TCP_URG,
+  EVEL_TCP_ACK,
+  EVEL_TCP_PSH,
+  EVEL_TCP_RST,
+  EVEL_TCP_SYN,
+  EVEL_TCP_FIN,
+  EVEL_MAX_TCP_FLAGS
+} EVEL_TCP_FLAGS;
+
+/**************************************************************************//**
+ * Mobile QCI Classes of Service.
+ * JSON equivalent fields: mobileQciCosCountList, mobileQciCosList
+ *****************************************************************************/
+typedef enum {
+
+  /***************************************************************************/
+  /* UMTS Classes of Service.                                                */
+  /***************************************************************************/
+  EVEL_QCI_COS_UMTS_CONVERSATIONAL,
+  EVEL_QCI_COS_UMTS_STREAMING,
+  EVEL_QCI_COS_UMTS_INTERACTIVE,
+  EVEL_QCI_COS_UMTS_BACKGROUND,
+
+  /***************************************************************************/
+  /* LTE Classes of Service.                                                 */
+  /***************************************************************************/
+  EVEL_QCI_COS_LTE_1,
+  EVEL_QCI_COS_LTE_2,
+  EVEL_QCI_COS_LTE_3,
+  EVEL_QCI_COS_LTE_4,
+  EVEL_QCI_COS_LTE_65,
+  EVEL_QCI_COS_LTE_66,
+  EVEL_QCI_COS_LTE_5,
+  EVEL_QCI_COS_LTE_6,
+  EVEL_QCI_COS_LTE_7,
+  EVEL_QCI_COS_LTE_8,
+  EVEL_QCI_COS_LTE_9,
+  EVEL_QCI_COS_LTE_69,
+  EVEL_QCI_COS_LTE_70,
+  EVEL_MAX_QCI_COS_TYPES
+} EVEL_QCI_COS_TYPES;
+
+/**************************************************************************//**
+ * Service Event endpoint description
+ * JSON equivalent field: endpointDesc
+ *****************************************************************************/
+typedef enum {
+  EVEL_SERVICE_ENDPOINT_CALLEE,
+  EVEL_SERVICE_ENDPOINT_CALLER,
+  EVEL_MAX_SERVICE_ENDPOINT_DESC
+} EVEL_SERVICE_ENDPOINT_DESC;
+
+/**************************************************************************//**
+ * Boolean type for EVEL library.
+ *****************************************************************************/
+typedef enum {
+  EVEL_FALSE,
+  EVEL_TRUE
+} EVEL_BOOLEAN;
+
+/**************************************************************************//**
+ * Optional parameter holder for double.
+ *****************************************************************************/
+typedef struct evel_option_double
+{
+  double value;
+  EVEL_BOOLEAN is_set;
+} EVEL_OPTION_DOUBLE;
+
+/**************************************************************************//**
+ * Optional parameter holder for string.
+ *****************************************************************************/
+typedef struct evel_option_string
+{
+  char * value;
+  EVEL_BOOLEAN is_set;
+} EVEL_OPTION_STRING;
+
+/**************************************************************************//**
+ * Optional parameter holder for int.
+ *****************************************************************************/
+typedef struct evel_option_int
+{
+  int value;
+  EVEL_BOOLEAN is_set;
+} EVEL_OPTION_INT;
+
+/**************************************************************************//**
+ * Optional parameter holder for unsigned long long.
+ *****************************************************************************/
+typedef struct evel_option_ull
+{
+  unsigned long long value;
+  EVEL_BOOLEAN is_set;
+} EVEL_OPTION_ULL;
+
+/**************************************************************************//**
+ * Optional parameter holder for time_t.
+ *****************************************************************************/
+typedef struct evel_option_time
+{
+  time_t value;
+  EVEL_BOOLEAN is_set;
+} EVEL_OPTION_TIME;
+
+/**************************************************************************//**
+ * enrichment fields for internal VES Event Listener service use only,
+ * not supplied by event sources
+ *****************************************************************************/
+typedef struct internal_header_fields
+{
+  void *object;
+  EVEL_BOOLEAN is_set;
+} EVEL_OPTION_INTHEADER_FIELDS;
+
+/*****************************************************************************/
+/* Supported Common Event Header version.                                    */
+/*****************************************************************************/
+#define EVEL_HEADER_MAJOR_VERSION 1
+#define EVEL_HEADER_MINOR_VERSION 2
+
+/**************************************************************************//**
+ * Event header.
+ * JSON equivalent field: commonEventHeader
+ *****************************************************************************/
+typedef struct event_header {
+  /***************************************************************************/
+  /* Version                                                                 */
+  /***************************************************************************/
+  int major_version;
+  int minor_version;
+
+  /***************************************************************************/
+  /* Mandatory fields                                                        */
+  /***************************************************************************/
+  EVEL_EVENT_DOMAINS event_domain;
+  char * event_id;
+  char * event_name;
+  char * source_name;
+  char * reporting_entity_name;
+  EVEL_EVENT_PRIORITIES priority;
+  unsigned long long start_epoch_microsec;
+  unsigned long long last_epoch_microsec;
+  int sequence;
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  EVEL_OPTION_STRING event_type;
+  EVEL_OPTION_STRING source_id;
+  EVEL_OPTION_STRING reporting_entity_id;
+  EVEL_OPTION_INTHEADER_FIELDS internal_field;
+  EVEL_OPTION_STRING nfcnaming_code;
+  EVEL_OPTION_STRING nfnaming_code;
+
+} EVENT_HEADER;
+
+/*****************************************************************************/
+/* Supported Fault version.                                                  */
+/*****************************************************************************/
+#define EVEL_FAULT_MAJOR_VERSION 2
+#define EVEL_FAULT_MINOR_VERSION 1
+
+/**************************************************************************//**
+ * Fault.
+ * JSON equivalent field: faultFields
+ *****************************************************************************/
+typedef struct event_fault {
+  /***************************************************************************/
+  /* Header and version                                                      */
+  /***************************************************************************/
+  EVENT_HEADER header;
+  int major_version;
+  int minor_version;
+
+  /***************************************************************************/
+  /* Mandatory fields                                                        */
+  /***************************************************************************/
+  EVEL_SEVERITIES event_severity;
+  EVEL_SOURCE_TYPES event_source_type;
+  char * alarm_condition;
+  char * specific_problem;
+  EVEL_VF_STATUSES vf_status;
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  EVEL_OPTION_STRING category;
+  EVEL_OPTION_STRING alarm_interface_a;
+  DLIST additional_info;
+
+} EVENT_FAULT;
+
+/**************************************************************************//**
+ * Fault Additional Info.
+ * JSON equivalent field: alarmAdditionalInformation
+ *****************************************************************************/
+typedef struct fault_additional_info {
+  char * name;
+  char * value;
+} FAULT_ADDL_INFO;
+
+
+/**************************************************************************//**
+ * optional field block for fields specific to heartbeat events
+ *****************************************************************************/
+typedef struct event_heartbeat_fields
+{
+  /***************************************************************************/
+  /* Header and version                                                      */
+  /***************************************************************************/
+  EVENT_HEADER header;
+  int major_version;
+  int minor_version;
+
+  /***************************************************************************/
+  /* Mandatory fields                                                        */
+  /***************************************************************************/
+  double heartbeat_version;
+  int    heartbeat_interval;
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  DLIST additional_info;
+
+} EVENT_HEARTBEAT_FIELD;
+
+/**************************************************************************//**
+ * tuple which provides the name of a key along with its value and
+ * relative order
+ *****************************************************************************/
+typedef struct internal_key
+{
+  char                *keyname;
+  EVEL_OPTION_INT      keyorder;
+  EVEL_OPTION_STRING   keyvalue;
+} EVEL_INTERNAL_KEY;
+
+/**************************************************************************//**
+ * meta-information about an instance of a jsonObject along with
+ * the actual object instance
+ *****************************************************************************/
+typedef struct json_object_instance
+{
+
+  char *jsonstring;
+  unsigned long long objinst_epoch_microsec;
+  DLIST object_keys; /*EVEL_INTERNAL_KEY list */
+
+} EVEL_JSON_OBJECT_INSTANCE;
+#define MAX_JSON_TOKENS 128
+/**************************************************************************//**
+ * Create a new json object instance.
+ *
+ * @note    The mandatory fields on the Other must be supplied to this factory
+ *          function and are immutable once set.  Optional fields have explicit
+ *          setter functions, but again values may only be set once so that the
+ *          Other has immutable properties.
+ * @param   yourjson       json string.
+ * @returns pointer to the newly manufactured ::EVEL_JSON_OBJECT_INSTANCE.
+ *          not used (i.e. posted) it must be released using ::evel_free_jsonobjectinstance.
+ * @retval  NULL  Failed to create the json object instance.
+ *****************************************************************************/
+EVEL_JSON_OBJECT_INSTANCE * evel_new_jsonobjinstance(const char *const yourjson);
+/**************************************************************************//**
+ * Free an json object instance.
+ *
+ * Free off the json object instance supplied.
+ *  Will free all the contained allocated memory.
+ *
+ *****************************************************************************/
+void evel_free_jsonobjinst(EVEL_JSON_OBJECT_INSTANCE * objinst);
+
+/**************************************************************************//**
+ * enrichment fields for internal VES Event Listener service use only,
+ * not supplied by event sources
+ *****************************************************************************/
+typedef struct json_object
+{
+
+  char *object_name;
+  EVEL_OPTION_STRING objectschema;
+  EVEL_OPTION_STRING objectschemaurl;
+  EVEL_OPTION_STRING nfsubscribedobjname;
+  EVEL_OPTION_STRING nfsubscriptionid;
+  DLIST jsonobjectinstances;  /* EVEL_JSON_OBJECT_INSTANCE list */
+
+} EVEL_JSON_OBJECT;
+
+/**************************************************************************//**
+ * Create a new json object.
+ *
+ * @note    The mandatory fields on the Other must be supplied to this factory
+ *          function and are immutable once set.  Optional fields have explicit
+ *          setter functions, but again values may only be set once so that the
+ *          Other has immutable properties.
+ * @param name       name of the object.
+ * @returns pointer to the newly manufactured ::EVEL_JSON_OBJECT.
+ *          not used (i.e. posted) it must be released using ::evel_free_jsonobject.
+ * @retval  NULL  Failed to create the json object.
+ *****************************************************************************/
+EVEL_JSON_OBJECT * evel_new_jsonobject(const char *const name);
+/**************************************************************************//**
+ * Free an json object.
+ *
+ * Free off the json object instance supplied.
+ *  Will free all the contained allocated memory.
+ *
+ *****************************************************************************/
+void evel_free_jsonobject(EVEL_JSON_OBJECT * jsobj);
+/*****************************************************************************/
+/* Supported Measurement version.                                            */
+/*****************************************************************************/
+#define EVEL_MEASUREMENT_MAJOR_VERSION 2
+#define EVEL_MEASUREMENT_MINOR_VERSION 1
+
+/**************************************************************************//**
+ * Errors.
+ * JSON equivalent field: errors
+ *****************************************************************************/
+typedef struct measurement_errors {
+  int receive_discards;
+  int receive_errors;
+  int transmit_discards;
+  int transmit_errors;
+} MEASUREMENT_ERRORS;
+
+/**************************************************************************//**
+ * Measurement.
+ * JSON equivalent field: measurementsForVfScalingFields
+ *****************************************************************************/
+typedef struct event_measurement {
+  /***************************************************************************/
+  /* Header and version                                                      */
+  /***************************************************************************/
+  EVENT_HEADER header;
+  int major_version;
+  int minor_version;
+
+  /***************************************************************************/
+  /* Mandatory fields                                                        */
+  /***************************************************************************/
+  double measurement_interval;
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  DLIST additional_info;
+  DLIST additional_measurements;
+  DLIST additional_objects;
+  DLIST codec_usage;
+  EVEL_OPTION_INT concurrent_sessions;
+  EVEL_OPTION_INT configured_entities;
+  DLIST cpu_usage;
+  DLIST disk_usage;
+  MEASUREMENT_ERRORS * errors;
+  DLIST feature_usage;
+  DLIST filesystem_usage;
+  DLIST latency_distribution;
+  EVEL_OPTION_DOUBLE mean_request_latency;
+  DLIST mem_usage;
+  EVEL_OPTION_INT media_ports_in_use;
+  EVEL_OPTION_INT request_rate;
+  EVEL_OPTION_INT vnfc_scaling_metric;
+  DLIST vnic_usage;
+
+} EVENT_MEASUREMENT;
+
+/**************************************************************************//**
+ * CPU Usage.
+ * JSON equivalent field: cpuUsage
+ *****************************************************************************/
+typedef struct measurement_cpu_use {
+  char * id;
+  double usage;
+  EVEL_OPTION_DOUBLE idle;
+  EVEL_OPTION_DOUBLE intrpt;
+  EVEL_OPTION_DOUBLE nice;
+  EVEL_OPTION_DOUBLE softirq;
+  EVEL_OPTION_DOUBLE steal;
+  EVEL_OPTION_DOUBLE sys;
+  EVEL_OPTION_DOUBLE user;
+  EVEL_OPTION_DOUBLE wait;
+} MEASUREMENT_CPU_USE;
+
+
+/**************************************************************************//**
+ * Disk Usage.
+ * JSON equivalent field: diskUsage
+ *****************************************************************************/
+typedef struct measurement_disk_use {
+  char * id;
+  EVEL_OPTION_DOUBLE iotimeavg;
+  EVEL_OPTION_DOUBLE iotimelast;
+  EVEL_OPTION_DOUBLE iotimemax;
+  EVEL_OPTION_DOUBLE iotimemin;
+  EVEL_OPTION_DOUBLE mergereadavg;
+  EVEL_OPTION_DOUBLE mergereadlast;
+  EVEL_OPTION_DOUBLE mergereadmax;
+  EVEL_OPTION_DOUBLE mergereadmin;
+  EVEL_OPTION_DOUBLE mergewriteavg;
+  EVEL_OPTION_DOUBLE mergewritelast;
+  EVEL_OPTION_DOUBLE mergewritemax;
+  EVEL_OPTION_DOUBLE mergewritemin;
+  EVEL_OPTION_DOUBLE octetsreadavg;
+  EVEL_OPTION_DOUBLE octetsreadlast;
+  EVEL_OPTION_DOUBLE octetsreadmax;
+  EVEL_OPTION_DOUBLE octetsreadmin;
+  EVEL_OPTION_DOUBLE octetswriteavg;
+  EVEL_OPTION_DOUBLE octetswritelast;
+  EVEL_OPTION_DOUBLE octetswritemax;
+  EVEL_OPTION_DOUBLE octetswritemin;
+  EVEL_OPTION_DOUBLE opsreadavg;
+  EVEL_OPTION_DOUBLE opsreadlast;
+  EVEL_OPTION_DOUBLE opsreadmax;
+  EVEL_OPTION_DOUBLE opsreadmin;
+  EVEL_OPTION_DOUBLE opswriteavg;
+  EVEL_OPTION_DOUBLE opswritelast;
+  EVEL_OPTION_DOUBLE opswritemax;
+  EVEL_OPTION_DOUBLE opswritemin;
+  EVEL_OPTION_DOUBLE pendingopsavg;
+  EVEL_OPTION_DOUBLE pendingopslast;
+  EVEL_OPTION_DOUBLE pendingopsmax;
+  EVEL_OPTION_DOUBLE pendingopsmin;
+  EVEL_OPTION_DOUBLE timereadavg;
+  EVEL_OPTION_DOUBLE timereadlast;
+  EVEL_OPTION_DOUBLE timereadmax;
+  EVEL_OPTION_DOUBLE timereadmin;
+  EVEL_OPTION_DOUBLE timewriteavg;
+  EVEL_OPTION_DOUBLE timewritelast;
+  EVEL_OPTION_DOUBLE timewritemax;
+  EVEL_OPTION_DOUBLE timewritemin;
+
+} MEASUREMENT_DISK_USE;
+
+/**************************************************************************//**
+ * Add an additional Disk usage value name/value pair to the Measurement.
+ *
+ * The name and value are null delimited ASCII strings.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param measurement   Pointer to the measurement.
+ * @param id            ASCIIZ string with the CPU's identifier.
+ * @param usage         Disk utilization.
+ *****************************************************************************/
+MEASUREMENT_DISK_USE * evel_measurement_new_disk_use_add(EVENT_MEASUREMENT * measurement, char * id);
+
+/**************************************************************************//**
+ * Filesystem Usage.
+ * JSON equivalent field: filesystemUsage
+ *****************************************************************************/
+typedef struct measurement_fsys_use {
+  char * filesystem_name;
+  double block_configured;
+  int block_iops;
+  double block_used;
+  double ephemeral_configured;
+  int ephemeral_iops;
+  double ephemeral_used;
+} MEASUREMENT_FSYS_USE;
+
+/**************************************************************************//**
+ * Memory Usage.
+ * JSON equivalent field: memoryUsage
+ *****************************************************************************/
+typedef struct measurement_mem_use {
+  char * id;
+  char * vmid;
+  double membuffsz;
+  EVEL_OPTION_DOUBLE memcache;
+  EVEL_OPTION_DOUBLE memconfig;
+  EVEL_OPTION_DOUBLE memfree;
+  EVEL_OPTION_DOUBLE slabrecl;
+  EVEL_OPTION_DOUBLE slabunrecl;
+  EVEL_OPTION_DOUBLE memused;
+} MEASUREMENT_MEM_USE;
+
+/**************************************************************************//**
+ * Add an additional Memory usage value name/value pair to the Measurement.
+ *
+ * The name and value are null delimited ASCII strings.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param measurement   Pointer to the measurement.
+ * @param id            ASCIIZ string with the Memory identifier.
+ * @param vmidentifier  ASCIIZ string with the VM's identifier.
+ * @param membuffsz     Memory Size.
+ *
+ * @return  Returns pointer to memory use structure in measurements
+ *****************************************************************************/
+MEASUREMENT_MEM_USE * evel_measurement_new_mem_use_add(EVENT_MEASUREMENT * measurement,
+                                 char * id,  char *vmidentifier,  double membuffsz);
+
+/**************************************************************************//**
+ * Set kilobytes of memory used for cache
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mem_use      Pointer to the Memory Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_mem_use_memcache_set(MEASUREMENT_MEM_USE * const mem_use,
+                                    const double val);
+/**************************************************************************//**
+ * Set kilobytes of memory configured in the virtual machine on which the VNFC reporting
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mem_use      Pointer to the Memory Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_mem_use_memconfig_set(MEASUREMENT_MEM_USE * const mem_use,
+                                    const double val);
+/**************************************************************************//**
+ * Set kilobytes of physical RAM left unused by the system
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mem_use      Pointer to the Memory Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_mem_use_memfree_set(MEASUREMENT_MEM_USE * const mem_use,
+                                    const double val);
+/**************************************************************************//**
+ * Set the part of the slab that can be reclaimed such as caches measured in kilobytes
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mem_use      Pointer to the Memory Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_mem_use_slab_reclaimed_set(MEASUREMENT_MEM_USE * const mem_use,
+                                    const double val);
+/**************************************************************************//**
+ * Set the part of the slab that cannot be reclaimed such as caches measured in kilobytes
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mem_use      Pointer to the Memory Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_mem_use_slab_unreclaimable_set(MEASUREMENT_MEM_USE * const mem_use,
+                                    const double val);
+/**************************************************************************//**
+ * Set the total memory minus the sum of free, buffered, cached and slab memory in kilobytes
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mem_use      Pointer to the Memory Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_mem_use_usedup_set(MEASUREMENT_MEM_USE * const mem_use,
+                                    const double val);
+/**************************************************************************//**
+ * Latency Bucket.
+ * JSON equivalent field: latencyBucketMeasure
+ *****************************************************************************/
+typedef struct measurement_latency_bucket {
+  int count;
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  EVEL_OPTION_DOUBLE high_end;
+  EVEL_OPTION_DOUBLE low_end;
+
+} MEASUREMENT_LATENCY_BUCKET;
+
+/**************************************************************************//**
+ * Virtual NIC usage.
+ * JSON equivalent field: vNicUsage
+ *****************************************************************************/
+typedef struct measurement_vnic_performance {
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  /*Cumulative count of broadcast packets received as read at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_bcast_packets_acc;
+  /*Count of broadcast packets received within the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_bcast_packets_delta;
+  /*Cumulative count of discarded packets received as read at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_discarded_packets_acc;
+  /*Count of discarded packets received within the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_discarded_packets_delta;
+  /*Cumulative count of error packets received as read at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_error_packets_acc;
+  /*Count of error packets received within the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_error_packets_delta;
+  /*Cumulative count of multicast packets received as read at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_mcast_packets_acc;
+  /*Count of mcast packets received within the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_mcast_packets_delta;
+  /*Cumulative count of octets received as read at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_octets_acc;
+  /*Count of octets received within the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_octets_delta;
+  /*Cumulative count of all packets received as read at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_total_packets_acc;
+  /*Count of all packets received within the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_total_packets_delta;
+  /*Cumulative count of unicast packets received as read at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_ucast_packets_acc;
+  /*Count of unicast packets received within the measurement interval*/
+  EVEL_OPTION_DOUBLE recvd_ucast_packets_delta;
+  /*Cumulative count of transmitted broadcast packets at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_bcast_packets_acc;
+  /*Count of transmitted broadcast packets within the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_bcast_packets_delta;
+  /*Cumulative count of transmit discarded packets at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_discarded_packets_acc;
+  /*Count of transmit discarded packets within the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_discarded_packets_delta;
+  /*Cumulative count of transmit error packets at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_error_packets_acc;
+  /*Count of transmit error packets within the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_error_packets_delta;
+  /*Cumulative count of transmit multicast packets at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_mcast_packets_acc;
+  /*Count of transmit multicast packets within the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_mcast_packets_delta;
+  /*Cumulative count of transmit octets at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_octets_acc;
+  /*Count of transmit octets received within the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_octets_delta;
+  /*Cumulative count of all transmit packets at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_total_packets_acc;
+  /*Count of transmit packets within the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_total_packets_delta;
+  /*Cumulative count of all transmit unicast packets at the end of
+   the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_ucast_packets_acc;
+  /*Count of transmit unicast packets within the measurement interval*/
+  EVEL_OPTION_DOUBLE tx_ucast_packets_delta;
+  /* Indicates whether vNicPerformance values are likely inaccurate
+           due to counter overflow or other condtions*/
+  char *valuesaresuspect;
+  char *vnic_id;
+
+} MEASUREMENT_VNIC_PERFORMANCE;
+
+/**************************************************************************//**
+ * Codec Usage.
+ * JSON equivalent field: codecsInUse
+ *****************************************************************************/
+typedef struct measurement_codec_use {
+  char * codec_id;
+  int number_in_use;
+} MEASUREMENT_CODEC_USE;
+
+/**************************************************************************//**
+ * Feature Usage.
+ * JSON equivalent field: featuresInUse
+ *****************************************************************************/
+typedef struct measurement_feature_use {
+  char * feature_id;
+  int feature_utilization;
+} MEASUREMENT_FEATURE_USE;
+
+/**************************************************************************//**
+ * Measurement Group.
+ * JSON equivalent field: additionalMeasurements
+ *****************************************************************************/
+typedef struct measurement_group {
+  char * name;
+  DLIST measurements;
+} MEASUREMENT_GROUP;
+
+/**************************************************************************//**
+ * Custom Defined Measurement.
+ * JSON equivalent field: measurements
+ *****************************************************************************/
+typedef struct custom_measurement {
+  char * name;
+  char * value;
+} CUSTOM_MEASUREMENT;
+
+/*****************************************************************************/
+/* Supported Report version.                                                 */
+/*****************************************************************************/
+#define EVEL_REPORT_MAJOR_VERSION 1
+#define EVEL_REPORT_MINOR_VERSION 1
+
+/**************************************************************************//**
+ * Report.
+ * JSON equivalent field: measurementsForVfReportingFields
+ *
+ * @note  This is an experimental event type and is not currently a formal part
+ *        of AT&T's specification.
+ *****************************************************************************/
+typedef struct event_report {
+  /***************************************************************************/
+  /* Header and version                                                      */
+  /***************************************************************************/
+  EVENT_HEADER header;
+  int major_version;
+  int minor_version;
+
+  /***************************************************************************/
+  /* Mandatory fields                                                        */
+  /***************************************************************************/
+  double measurement_interval;
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  DLIST feature_usage;
+  DLIST measurement_groups;
+
+} EVENT_REPORT;
+
+/**************************************************************************//**
+ * Mobile GTP Per Flow Metrics.
+ * JSON equivalent field: gtpPerFlowMetrics
+ *****************************************************************************/
+typedef struct mobile_gtp_per_flow_metrics {
+  double avg_bit_error_rate;
+  double avg_packet_delay_variation;
+  int avg_packet_latency;
+  int avg_receive_throughput;
+  int avg_transmit_throughput;
+  int flow_activation_epoch;
+  int flow_activation_microsec;
+  int flow_deactivation_epoch;
+  int flow_deactivation_microsec;
+  time_t flow_deactivation_time;
+  char * flow_status;
+  int max_packet_delay_variation;
+  int num_activation_failures;
+  int num_bit_errors;
+  int num_bytes_received;
+  int num_bytes_transmitted;
+  int num_dropped_packets;
+  int num_l7_bytes_received;
+  int num_l7_bytes_transmitted;
+  int num_lost_packets;
+  int num_out_of_order_packets;
+  int num_packet_errors;
+  int num_packets_received_excl_retrans;
+  int num_packets_received_incl_retrans;
+  int num_packets_transmitted_incl_retrans;
+  int num_retries;
+  int num_timeouts;
+  int num_tunneled_l7_bytes_received;
+  int round_trip_time;
+  int time_to_first_byte;
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  EVEL_OPTION_INT ip_tos_counts[EVEL_TOS_SUPPORTED];
+  EVEL_OPTION_INT tcp_flag_counts[EVEL_MAX_TCP_FLAGS];
+  EVEL_OPTION_INT qci_cos_counts[EVEL_MAX_QCI_COS_TYPES];
+  EVEL_OPTION_INT dur_connection_failed_status;
+  EVEL_OPTION_INT dur_tunnel_failed_status;
+  EVEL_OPTION_STRING flow_activated_by;
+  EVEL_OPTION_TIME flow_activation_time;
+  EVEL_OPTION_STRING flow_deactivated_by;
+  EVEL_OPTION_STRING gtp_connection_status;
+  EVEL_OPTION_STRING gtp_tunnel_status;
+  EVEL_OPTION_INT large_packet_rtt;
+  EVEL_OPTION_DOUBLE large_packet_threshold;
+  EVEL_OPTION_INT max_receive_bit_rate;
+  EVEL_OPTION_INT max_transmit_bit_rate;
+  EVEL_OPTION_INT num_gtp_echo_failures;
+  EVEL_OPTION_INT num_gtp_tunnel_errors;
+  EVEL_OPTION_INT num_http_errors;
+
+} MOBILE_GTP_PER_FLOW_METRICS;
+
+/*****************************************************************************/
+/* Supported Mobile Flow version.                                            */
+/*****************************************************************************/
+#define EVEL_MOBILE_FLOW_MAJOR_VERSION 1
+#define EVEL_MOBILE_FLOW_MINOR_VERSION 2
+
+/**************************************************************************//**
+ * Mobile Flow.
+ * JSON equivalent field: mobileFlow
+ *****************************************************************************/
+typedef struct event_mobile_flow {
+  /***************************************************************************/
+  /* Header and version                                                      */
+  /***************************************************************************/
+  EVENT_HEADER header;
+  int major_version;
+  int minor_version;
+
+  /***************************************************************************/
+  /* Mandatory fields                                                        */
+  /***************************************************************************/
+  char * flow_direction;
+  MOBILE_GTP_PER_FLOW_METRICS * gtp_per_flow_metrics;
+  char * ip_protocol_type;
+  char * ip_version;
+  char * other_endpoint_ip_address;
+  int other_endpoint_port;
+  char * reporting_endpoint_ip_addr;
+  int reporting_endpoint_port;
+  DLIST additional_info;                         /* JSON: additionalFields */
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  EVEL_OPTION_STRING application_type;
+  EVEL_OPTION_STRING app_protocol_type;
+  EVEL_OPTION_STRING app_protocol_version;
+  EVEL_OPTION_STRING cid;
+  EVEL_OPTION_STRING connection_type;
+  EVEL_OPTION_STRING ecgi;
+  EVEL_OPTION_STRING gtp_protocol_type;
+  EVEL_OPTION_STRING gtp_version;
+  EVEL_OPTION_STRING http_header;
+  EVEL_OPTION_STRING imei;
+  EVEL_OPTION_STRING imsi;
+  EVEL_OPTION_STRING lac;
+  EVEL_OPTION_STRING mcc;
+  EVEL_OPTION_STRING mnc;
+  EVEL_OPTION_STRING msisdn;
+  EVEL_OPTION_STRING other_functional_role;
+  EVEL_OPTION_STRING rac;
+  EVEL_OPTION_STRING radio_access_technology;
+  EVEL_OPTION_STRING sac;
+  EVEL_OPTION_INT sampling_algorithm;
+  EVEL_OPTION_STRING tac;
+  EVEL_OPTION_STRING tunnel_id;
+  EVEL_OPTION_STRING vlan_id;
+
+} EVENT_MOBILE_FLOW;
+
+/*****************************************************************************/
+/* Supported Other field version.                                            */
+/*****************************************************************************/
+#define EVEL_OTHER_EVENT_MAJOR_VERSION 1
+#define EVEL_OTHER_EVENT_MINOR_VERSION 1
+
+/**************************************************************************//**
+ * Other.
+ * JSON equivalent field: otherFields
+ *****************************************************************************/
+typedef struct event_other {
+  EVENT_HEADER header;
+  int major_version;
+  int minor_version;
+
+  HASHTABLE_T *namedarrays; /* HASHTABLE_T */
+  DLIST jsonobjects; /* DLIST of EVEL_JSON_OBJECT */
+  DLIST namedvalues;
+} EVENT_OTHER;
+
+/**************************************************************************//**
+ * Other Field.
+ * JSON equivalent field: otherFields
+ *****************************************************************************/
+typedef struct other_field {
+  char * name;
+  char * value;
+} OTHER_FIELD;
+
+
+/*****************************************************************************/
+/* Supported Service Events version.                                         */
+/*****************************************************************************/
+#define EVEL_HEARTBEAT_FIELD_MAJOR_VERSION 1
+#define EVEL_HEARTBEAT_FIELD_MINOR_VERSION 1
+
+
+/*****************************************************************************/
+/* Supported Signaling version.                                              */
+/*****************************************************************************/
+#define EVEL_SIGNALING_MAJOR_VERSION 2
+#define EVEL_SIGNALING_MINOR_VERSION 1
+
+/**************************************************************************//**
+ * Vendor VNF Name fields.
+ * JSON equivalent field: vendorVnfNameFields
+ *****************************************************************************/
+typedef struct vendor_vnfname_field {
+  char * vendorname;
+  EVEL_OPTION_STRING vfmodule;
+  EVEL_OPTION_STRING vnfname;
+} VENDOR_VNFNAME_FIELD;
+
+/**************************************************************************//**
+ * Signaling.
+ * JSON equivalent field: signalingFields
+ *****************************************************************************/
+typedef struct event_signaling {
+  /***************************************************************************/
+  /* Header and version                                                      */
+  /***************************************************************************/
+  EVENT_HEADER header;
+  int major_version;
+  int minor_version;
+
+  /***************************************************************************/
+  /* Mandatory fields                                                        */
+  /***************************************************************************/
+  VENDOR_VNFNAME_FIELD vnfname_field;
+  EVEL_OPTION_STRING correlator;                         /* JSON: correlator */
+  EVEL_OPTION_STRING local_ip_address;               /* JSON: localIpAddress */
+  EVEL_OPTION_STRING local_port;                          /* JSON: localPort */
+  EVEL_OPTION_STRING remote_ip_address;             /* JSON: remoteIpAddress */
+  EVEL_OPTION_STRING remote_port;                        /* JSON: remotePort */
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  EVEL_OPTION_STRING compressed_sip;                  /* JSON: compressedSip */
+  EVEL_OPTION_STRING summary_sip;                        /* JSON: summarySip */
+  DLIST additional_info;
+
+} EVENT_SIGNALING;
+
+/**************************************************************************//**
+ * Sgnaling Additional Field.
+ * JSON equivalent field: additionalFields
+ *****************************************************************************/
+typedef struct signaling_additional_field {
+  char * name;
+  char * value;
+} SIGNALING_ADDL_FIELD;
+
+/*****************************************************************************/
+/* Supported State Change version.                                           */
+/*****************************************************************************/
+#define EVEL_STATE_CHANGE_MAJOR_VERSION 1
+#define EVEL_STATE_CHANGE_MINOR_VERSION 2
+
+/**************************************************************************//**
+ * State Change.
+ * JSON equivalent field: stateChangeFields
+ *****************************************************************************/
+typedef struct event_state_change {
+  /***************************************************************************/
+  /* Header and version                                                      */
+  /***************************************************************************/
+  EVENT_HEADER header;
+  int major_version;
+  int minor_version;
+
+  /***************************************************************************/
+  /* Mandatory fields                                                        */
+  /***************************************************************************/
+  EVEL_ENTITY_STATE new_state;
+  EVEL_ENTITY_STATE old_state;
+  char * state_interface;
+  double version;
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  DLIST additional_fields;
+
+} EVENT_STATE_CHANGE;
+
+/**************************************************************************//**
+ * State Change Additional Field.
+ * JSON equivalent field: additionalFields
+ *****************************************************************************/
+typedef struct state_change_additional_field {
+  char * name;
+  char * value;
+} STATE_CHANGE_ADDL_FIELD;
+
+/*****************************************************************************/
+/* Supported Syslog version.                                                 */
+/*****************************************************************************/
+#define EVEL_SYSLOG_MAJOR_VERSION 1
+#define EVEL_SYSLOG_MINOR_VERSION 2
+
+/**************************************************************************//**
+ * Syslog.
+ * JSON equivalent field: syslogFields
+ *****************************************************************************/
+typedef struct event_syslog {
+  /***************************************************************************/
+  /* Header and version                                                      */
+  /***************************************************************************/
+  EVENT_HEADER header;
+  int major_version;
+  int minor_version;
+
+  /***************************************************************************/
+  /* Mandatory fields                                                        */
+  /***************************************************************************/
+  EVEL_SOURCE_TYPES event_source_type;
+  char * syslog_msg;
+  char * syslog_tag;
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  EVEL_OPTION_STRING additional_filters;
+  EVEL_OPTION_STRING event_source_host;
+  EVEL_OPTION_INT syslog_facility;
+  EVEL_OPTION_INT syslog_priority;
+  EVEL_OPTION_STRING syslog_proc;
+  EVEL_OPTION_INT syslog_proc_id;
+  EVEL_OPTION_STRING syslog_s_data;
+  EVEL_OPTION_STRING syslog_sdid;
+  EVEL_OPTION_STRING syslog_severity;
+  double syslog_fver;
+  EVEL_OPTION_INT syslog_ver;
+
+} EVENT_SYSLOG;
+
+/**************************************************************************//**
+ * Copyright.
+ * JSON equivalent object: attCopyrightNotice
+ *****************************************************************************/
+typedef struct copyright {
+  char * useAndRedistribution;
+  char * condition1;
+  char * condition2;
+  char * condition3;
+  char * condition4;
+  char * disclaimerLine1;
+  char * disclaimerLine2;
+  char * disclaimerLine3;
+  char * disclaimerLine4;
+} COPYRIGHT;
+
+/**************************************************************************//**
+ * Library initialization.
+ *
+ * Initialize the EVEL library.
+ *
+ * @note  This function initializes the cURL library.  Applications making use
+ *        of libcurl may need to pull the initialization out of here.  Note
+ *        also that this function is not threadsafe as a result - refer to
+ *        libcurl's API documentation for relevant warnings.
+ *
+ * @sa  Matching Term function.
+ *
+ * @param   fqdn    The API's FQDN or IP address.
+ * @param   port    The API's port.
+ * @param   path    The optional path (may be NULL).
+ * @param   topic   The optional topic part of the URL (may be NULL).
+ * @param   secure  Whether to use HTTPS (0=HTTP, 1=HTTPS).
+ * @param   username  Username for Basic Authentication of requests.
+ * @param   password  Password for Basic Authentication of requests.
+ * @param   source_type The kind of node we represent.
+ * @param   role    The role this node undertakes.
+ * @param   verbosity  0 for normal operation, positive values for chattier
+ *                     logs.
+ *
+ * @returns Status code
+ * @retval  EVEL_SUCCESS      On success
+ * @retval  ::EVEL_ERR_CODES  On failure.
+ *****************************************************************************/
+EVEL_ERR_CODES evel_initialize(const char * const fqdn,
+                               int port,
+                               const char * const path,
+                               const char * const topic,
+                               int secure,
+                               const char * const username,
+                               const char * const password,
+                               EVEL_SOURCE_TYPES source_type,
+                               const char * const role,
+                               int verbosity
+                               );
+
+/**************************************************************************//**
+ * Clean up the EVEL library.
+ *
+ * @note that at present don't expect Init/Term cycling not to leak memory!
+ *
+ * @returns Status code
+ * @retval  EVEL_SUCCESS On success
+ * @retval  "One of ::EVEL_ERR_CODES" On failure.
+ *****************************************************************************/
+EVEL_ERR_CODES evel_terminate(void);
+
+EVEL_ERR_CODES evel_post_event(EVENT_HEADER * event);
+const char * evel_error_string(void);
+
+
+/**************************************************************************//**
+ * Free an event.
+ *
+ * Free off the event supplied.  Will free all the contained allocated memory.
+ *
+ * @note  It is safe to free a NULL pointer.
+ *****************************************************************************/
+void evel_free_event(void * event);
+
+/**************************************************************************//**
+ * Encode the event as a JSON event object according to AT&T's schema.
+ *
+ * @param json      Pointer to where to store the JSON encoded data.
+ * @param max_size  Size of storage available in json_body.
+ * @param event     Pointer to the ::EVENT_HEADER to encode.
+ * @returns Number of bytes actually written.
+ *****************************************************************************/
+int evel_json_encode_event(char * json,
+                           int max_size,
+                           EVENT_HEADER * event);
+
+/**************************************************************************//**
+ * Initialize an event instance id.
+ *
+ * @param vfield        Pointer to the event vnfname field being initialized.
+ * @param vendor_id     The vendor id to encode in the event instance id.
+ * @param event_id      The event id to encode in the event instance id.
+ *****************************************************************************/
+void evel_init_vendor_field(VENDOR_VNFNAME_FIELD * const vfield,
+                                 const char * const vendor_name);
+
+/**************************************************************************//**
+ * Set the Vendor module property of the Vendor.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vfield        Pointer to the Vendor field.
+ * @param module_name   The module name to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_vendor_field_module_set(VENDOR_VNFNAME_FIELD * const vfield,
+                                    const char * const module_name);
+/**************************************************************************//**
+ * Set the Vendor module property of the Vendor.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vfield        Pointer to the Vendor field.
+ * @param module_name   The module name to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_vendor_field_vnfname_set(VENDOR_VNFNAME_FIELD * const vfield,
+                                    const char * const vnfname);
+/**************************************************************************//**
+ * Free an event instance id.
+ *
+ * @param vfield   Pointer to the event vnfname_field being freed.
+ *****************************************************************************/
+void evel_free_event_vendor_field(VENDOR_VNFNAME_FIELD * const vfield);
+
+/**************************************************************************//**
+ * Callback function to provide returned data.
+ *
+ * Copy data into the supplied buffer, write_callback::ptr, checking size
+ * limits.
+ *
+ * @returns   Number of bytes placed into write_callback::ptr. 0 for EOF.
+ *****************************************************************************/
+size_t evel_write_callback(void *contents,
+                           size_t size,
+                           size_t nmemb,
+                           void *userp);
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   HEARTBEAT - (includes common header, too)                               */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+/**************************************************************************//**
+ * Create a new heartbeat event.
+ *
+ * @note that the heartbeat is just a "naked" commonEventHeader!
+ *
+ * @returns pointer to the newly manufactured ::EVENT_HEADER.  If the event is
+ *          not used it must be released using ::evel_free_event
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_HEADER * evel_new_heartbeat(void);
+
+/**************************************************************************//**
+ * Create a new heartbeat event of given name and type.
+ *
+ * @note that the heartbeat is just a "naked" commonEventHeader!
+ *
+ * @param event_name  Unique Event Name confirming Domain AsdcModel Description
+ * @param event_id    A universal identifier of the event for: troubleshooting correlation, analysis, etc
+ *
+ * @returns pointer to the newly manufactured ::EVENT_HEADER.  If the event is
+ *          not used it must be released using ::evel_free_event
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_HEADER * evel_new_heartbeat_nameid(const char* ev_name, const char *ev_id);
+
+
+/**************************************************************************//**
+ * Free an event header.
+ *
+ * Free off the event header supplied.  Will free all the contained allocated
+ * memory.
+ *
+ * @note It does not free the header itself, since that may be part of a
+ * larger structure.
+ *****************************************************************************/
+void evel_free_header(EVENT_HEADER * const event);
+
+/**************************************************************************//**
+ * Initialize a newly created event header.
+ *
+ * @param header  Pointer to the header being initialized.
+ *****************************************************************************/
+void evel_init_header(EVENT_HEADER * const header,const char *const eventname);
+
+/**************************************************************************//**
+ * Set the Event Type property of the event header.
+ *
+ * @param header        Pointer to the ::EVENT_HEADER.
+ * @param type          The Event Type to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_header_type_set(EVENT_HEADER * const header,
+                          const char * const type);
+
+/**************************************************************************//**
+ * Set the Start Epoch property of the event header.
+ *
+ * @note The Start Epoch defaults to the time of event creation.
+ *
+ * @param header        Pointer to the ::EVENT_HEADER.
+ * @param start_epoch_microsec
+ *                      The start epoch to set, in microseconds.
+ *****************************************************************************/
+void evel_start_epoch_set(EVENT_HEADER * const header,
+                          const unsigned long long start_epoch_microsec);
+
+/**************************************************************************//**
+ * Set the Last Epoch property of the event header.
+ *
+ * @note The Last Epoch defaults to the time of event creation.
+ *
+ * @param header        Pointer to the ::EVENT_HEADER.
+ * @param last_epoch_microsec
+ *                      The last epoch to set, in microseconds.
+ *****************************************************************************/
+void evel_last_epoch_set(EVENT_HEADER * const header,
+                         const unsigned long long last_epoch_microsec);
+
+/**************************************************************************//**
+ * Set the Reporting Entity Name property of the event header.
+ *
+ * @note The Reporting Entity Name defaults to the OpenStack VM Name.
+ *
+ * @param header        Pointer to the ::EVENT_HEADER.
+ * @param entity_name   The entity name to set.
+ *****************************************************************************/
+void evel_reporting_entity_name_set(EVENT_HEADER * const header,
+                                    const char * const entity_name);
+
+/**************************************************************************//**
+ * Set the Reporting Entity Id property of the event header.
+ *
+ * @note The Reporting Entity Id defaults to the OpenStack VM UUID.
+ *
+ * @param header        Pointer to the ::EVENT_HEADER.
+ * @param entity_id     The entity id to set.
+ *****************************************************************************/
+void evel_reporting_entity_id_set(EVENT_HEADER * const header,
+                                  const char * const entity_id);
+
+/**************************************************************************//**
+ * Set the NFC Naming code property of the event header.
+ *
+ * @param header        Pointer to the ::EVENT_HEADER.
+ * @param nfcnamingcode String
+ *****************************************************************************/
+void evel_nfcnamingcode_set(EVENT_HEADER * const header,
+                         const char * const nfcnam);
+/**************************************************************************//**
+ * Set the NF Naming code property of the event header.
+ *
+ * @param header        Pointer to the ::EVENT_HEADER.
+ * @param nfnamingcode String
+ *****************************************************************************/
+void evel_nfnamingcode_set(EVENT_HEADER * const header,
+                         const char * const nfnam);
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   FAULT                                                                   */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+/**************************************************************************//**
+ * Create a new fault event.
+ *
+ * @note    The mandatory fields on the Fault must be supplied to this factory
+ *          function and are immutable once set.  Optional fields have explicit
+ *          setter functions, but again values may only be set once so that the
+ *          Fault has immutable properties.
+ * @param event_name    Unique Event Name
+ * @param event_id    A universal identifier of the event for analysis etc
+ * @param   condition   The condition indicated by the Fault.
+ * @param   specific_problem  The specific problem triggering the fault.
+ * @param   priority    The priority of the event.
+ * @param   severity    The severity of the Fault.
+ * @param   ev_source_type    Source of Alarm event
+ * @param   version     fault version
+ * @param   status      status of Virtual Function
+ * @returns pointer to the newly manufactured ::EVENT_FAULT.  If the event is
+ *          not used (i.e. posted) it must be released using ::evel_free_fault.
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_FAULT * evel_new_fault(const char* ev_name, const char *ev_id,
+			     const char * const condition,
+                             const char * const specific_problem,
+                             EVEL_EVENT_PRIORITIES priority,
+                             EVEL_SEVERITIES severity,
+                             EVEL_SOURCE_TYPES ev_source_type,
+                             EVEL_VF_STATUSES status);
+
+/**************************************************************************//**
+ * Free a Fault.
+ *
+ * Free off the Fault supplied.  Will free all the contained allocated memory.
+ *
+ * @note It does not free the Fault itself, since that may be part of a
+ * larger structure.
+ *****************************************************************************/
+void evel_free_fault(EVENT_FAULT * event);
+
+/**************************************************************************//**
+ * Set the Fault Category property of the Fault.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param fault      Pointer to the fault.
+ * @param category   Category : license, link, routing, security, signaling.
+ *                       ASCIIZ string. The caller
+ *                   does not need to preserve the value once the function
+ *                   returns.
+ *****************************************************************************/
+void evel_fault_category_set(EVENT_FAULT * fault,
+                              const char * const category);
+
+/**************************************************************************//**
+ * Set the Alarm Interface A property of the Fault.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param fault      Pointer to the fault.
+ * @param interface  The Alarm Interface A to be set. ASCIIZ string. The caller
+ *                   does not need to preserve the value once the function
+ *                   returns.
+ *****************************************************************************/
+void evel_fault_interface_set(EVENT_FAULT * fault,
+                              const char * const interface);
+
+/**************************************************************************//**
+ * Add an additional value name/value pair to the Fault.
+ *
+ * The name and value are null delimited ASCII strings.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param fault     Pointer to the fault.
+ * @param name      ASCIIZ string with the attribute's name.
+ * @param value     ASCIIZ string with the attribute's value.
+ *****************************************************************************/
+void evel_fault_addl_info_add(EVENT_FAULT * fault, char * name, char * value);
+
+/**************************************************************************//**
+ * Set the Event Type property of the Fault.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param fault      Pointer to the fault.
+ * @param type       The Event Type to be set. ASCIIZ string. The caller
+ *                   does not need to preserve the value once the function
+ *                   returns.
+ *****************************************************************************/
+void evel_fault_type_set(EVENT_FAULT * fault, const char * const type);
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   MEASUREMENT                                                             */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+/**************************************************************************//**
+ * Create a new Measurement event.
+ *
+ * @note    The mandatory fields on the Measurement must be supplied to this
+ *          factory function and are immutable once set.  Optional fields have
+ *          explicit setter functions, but again values may only be set once so
+ *          that the Measurement has immutable properties.
+ *
+ * @param   measurement_interval
+ * @param event_name    Unique Event Name
+ * @param event_id    A universal identifier of the event for analysis etc
+ *
+ * @returns pointer to the newly manufactured ::EVENT_MEASUREMENT.  If the
+ *          event is not used (i.e. posted) it must be released using
+ *          ::evel_free_event.
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_MEASUREMENT * evel_new_measurement(double measurement_interval,const char* ev_name, const char *ev_id);
+
+/**************************************************************************//**
+ * Free a Measurement.
+ *
+ * Free off the Measurement supplied.  Will free all the contained allocated
+ * memory.
+ *
+ * @note It does not free the Measurement itself, since that may be part of a
+ * larger structure.
+ *****************************************************************************/
+void evel_free_measurement(EVENT_MEASUREMENT * event);
+
+/**************************************************************************//**
+ * Set the Event Type property of the Measurement.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param measurement Pointer to the Measurement.
+ * @param type        The Event Type to be set. ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_measurement_type_set(EVENT_MEASUREMENT * measurement,
+                               const char * const type);
+
+/**************************************************************************//**
+ * Set the Concurrent Sessions property of the Measurement.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param measurement         Pointer to the Measurement.
+ * @param concurrent_sessions The Concurrent Sessions to be set.
+ *****************************************************************************/
+void evel_measurement_conc_sess_set(EVENT_MEASUREMENT * measurement,
+                                    int concurrent_sessions);
+
+/**************************************************************************//**
+ * Set the Configured Entities property of the Measurement.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param measurement         Pointer to the Measurement.
+ * @param configured_entities The Configured Entities to be set.
+ *****************************************************************************/
+void evel_measurement_cfg_ents_set(EVENT_MEASUREMENT * measurement,
+                                   int configured_entities);
+
+/**************************************************************************//**
+ * Add an additional set of Errors to the Measurement.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param measurement       Pointer to the measurement.
+ * @param receive_discards  The number of receive discards.
+ * @param receive_errors    The number of receive errors.
+ * @param transmit_discards The number of transmit discards.
+ * @param transmit_errors   The number of transmit errors.
+ *****************************************************************************/
+void evel_measurement_errors_set(EVENT_MEASUREMENT * measurement,
+                                 int receive_discards,
+                                 int receive_errors,
+                                 int transmit_discards,
+                                 int transmit_errors);
+
+/**************************************************************************//**
+ * Set the Mean Request Latency property of the Measurement.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param measurement          Pointer to the Measurement.
+ * @param mean_request_latency The Mean Request Latency to be set.
+ *****************************************************************************/
+void evel_measurement_mean_req_lat_set(EVENT_MEASUREMENT * measurement,
+                                       double mean_request_latency);
+
+/**************************************************************************//**
+ * Set the Request Rate property of the Measurement.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param measurement  Pointer to the Measurement.
+ * @param request_rate The Request Rate to be set.
+ *****************************************************************************/
+void evel_measurement_request_rate_set(EVENT_MEASUREMENT * measurement,
+                                       int request_rate);
+
+/**************************************************************************//**
+ * Add an additional CPU usage value name/value pair to the Measurement.
+ *
+ * The name and value are null delimited ASCII strings.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param measurement   Pointer to the measurement.
+ * @param id            ASCIIZ string with the CPU's identifier.
+ * @param usage         CPU utilization.
+ *****************************************************************************/
+MEASUREMENT_CPU_USE * evel_measurement_new_cpu_use_add(EVENT_MEASUREMENT * measurement, char * id, double usage);
+
+/**************************************************************************//**
+ * Set the CPU Idle value in measurement interval
+ *   percentage of CPU time spent in the idle task
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param cpu_use      Pointer to the CPU Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_cpu_use_idle_set(MEASUREMENT_CPU_USE *const cpu_use,
+                                    const double val);
+
+/**************************************************************************//**
+ * Set the percentage of time spent servicing interrupts
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param cpu_use      Pointer to the CPU Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_cpu_use_interrupt_set(MEASUREMENT_CPU_USE * const cpu_use,
+                                    const double val);
+
+/**************************************************************************//**
+ * Set the percentage of time spent running user space processes that have been niced
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param cpu_use      Pointer to the CPU Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_cpu_use_nice_set(MEASUREMENT_CPU_USE * const cpu_use,
+                                    const double val);
+
+/**************************************************************************//**
+ * Set the percentage of time spent handling soft irq interrupts
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param cpu_use      Pointer to the CPU Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_cpu_use_softirq_set(MEASUREMENT_CPU_USE * const cpu_use,
+                                    const double val);
+/**************************************************************************//**
+ * Set the percentage of time spent in involuntary wait
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param cpu_use      Pointer to the CPU Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_cpu_use_steal_set(MEASUREMENT_CPU_USE * const cpu_use,
+                                    const double val);
+/**************************************************************************//**
+ * Set the percentage of time spent on system tasks running the kernel
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param cpu_use      Pointer to the CPU Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_cpu_use_system_set(MEASUREMENT_CPU_USE * const cpu_use,
+                                    const double val);
+/**************************************************************************//**
+ * Set the percentage of time spent running un-niced user space processes
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param cpu_use      Pointer to the CPU Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_cpu_use_usageuser_set(MEASUREMENT_CPU_USE * const cpu_use,
+                                    const double val);
+/**************************************************************************//**
+ * Set the percentage of CPU time spent waiting for I/O operations to complete
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param cpu_use      Pointer to the CPU Use.
+ * @param val          double
+ *****************************************************************************/
+void evel_measurement_cpu_use_wait_set(MEASUREMENT_CPU_USE * const cpu_use,
+                                    const double val);
+
+/**************************************************************************//**
+ * Add an additional File System usage value name/value pair to the
+ * Measurement.
+ *
+ * The filesystem_name is null delimited ASCII string.  The library takes a
+ * copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param measurement     Pointer to the measurement.
+ * @param filesystem_name   ASCIIZ string with the file-system's UUID.
+ * @param block_configured  Block storage configured.
+ * @param block_used        Block storage in use.
+ * @param block_iops        Block storage IOPS.
+ * @param ephemeral_configured  Ephemeral storage configured.
+ * @param ephemeral_used        Ephemeral storage in use.
+ * @param ephemeral_iops        Ephemeral storage IOPS.
+ *****************************************************************************/
+void evel_measurement_fsys_use_add(EVENT_MEASUREMENT * measurement,
+                                   char * filesystem_name,
+                                   double block_configured,
+                                   double block_used,
+                                   int block_iops,
+                                   double ephemeral_configured,
+                                   double ephemeral_used,
+                                   int ephemeral_iops);
+
+/**************************************************************************//**
+ * Add a Feature usage value name/value pair to the Measurement.
+ *
+ * The name is null delimited ASCII string.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param measurement     Pointer to the measurement.
+ * @param feature         ASCIIZ string with the feature's name.
+ * @param utilization     Utilization of the feature.
+ *****************************************************************************/
+void evel_measurement_feature_use_add(EVENT_MEASUREMENT * measurement,
+                                      char * feature,
+                                      int utilization);
+
+/**************************************************************************//**
+ * Add a Additional Measurement value name/value pair to the Measurement.
+ *
+ * The name is null delimited ASCII string.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param measurement   Pointer to the Measurement.
+ * @param group    ASCIIZ string with the measurement group's name.
+ * @param name     ASCIIZ string containing the measurement's name.
+ * @param name     ASCIIZ string containing the measurement's value.
+ *****************************************************************************/
+void evel_measurement_custom_measurement_add(EVENT_MEASUREMENT * measurement,
+                                             const char * const group,
+                                             const char * const name,
+                                             const char * const value);
+
+/**************************************************************************//**
+ * Add a Codec usage value name/value pair to the Measurement.
+ *
+ * The name is null delimited ASCII string.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param measurement     Pointer to the measurement.
+ * @param codec           ASCIIZ string with the codec's name.
+ * @param utilization     Utilization of the feature.
+ *****************************************************************************/
+void evel_measurement_codec_use_add(EVENT_MEASUREMENT * measurement,
+                                    char * codec,
+                                    int utilization);
+
+/**************************************************************************//**
+ * Set the Media Ports in Use property of the Measurement.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param measurement         Pointer to the measurement.
+ * @param media_ports_in_use  The media port usage to set.
+ *****************************************************************************/
+void evel_measurement_media_port_use_set(EVENT_MEASUREMENT * measurement,
+                                         int media_ports_in_use);
+
+/**************************************************************************//**
+ * Set the VNFC Scaling Metric property of the Measurement.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param measurement     Pointer to the measurement.
+ * @param scaling_metric  The scaling metric to set.
+ *****************************************************************************/
+void evel_measurement_vnfc_scaling_metric_set(EVENT_MEASUREMENT * measurement,
+                                              int scaling_metric);
+
+/**************************************************************************//**
+ * Create a new Latency Bucket to be added to a Measurement event.
+ *
+ * @note    The mandatory fields on the ::MEASUREMENT_LATENCY_BUCKET must be
+ *          supplied to this factory function and are immutable once set.
+ *          Optional fields have explicit setter functions, but again values
+ *          may only be set once so that the ::MEASUREMENT_LATENCY_BUCKET has
+ *          immutable properties.
+ *
+ * @param count         Count of events in this bucket.
+ *
+ * @returns pointer to the newly manufactured ::MEASUREMENT_LATENCY_BUCKET.
+ * @retval  NULL  Failed to create the Latency Bucket.
+ *****************************************************************************/
+MEASUREMENT_LATENCY_BUCKET * evel_new_meas_latency_bucket(const int count);
+
+/**************************************************************************//**
+ * Set the High End property of the Measurement Latency Bucket.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param bucket        Pointer to the Measurement Latency Bucket.
+ * @param high_end      High end of the bucket's range.
+ *****************************************************************************/
+void evel_meas_latency_bucket_high_end_set(
+                                     MEASUREMENT_LATENCY_BUCKET * const bucket,
+                                     const double high_end);
+
+/**************************************************************************//**
+ * Set the Low End property of the Measurement Latency Bucket.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param bucket        Pointer to the Measurement Latency Bucket.
+ * @param low_end       Low end of the bucket's range.
+ *****************************************************************************/
+void evel_meas_latency_bucket_low_end_set(
+                                     MEASUREMENT_LATENCY_BUCKET * const bucket,
+                                     const double low_end);
+
+/**************************************************************************//**
+ * Add an additional Measurement Latency Bucket to the specified event.
+ *
+ * @param measurement   Pointer to the Measurement event.
+ * @param bucket        Pointer to the Measurement Latency Bucket to add.
+ *****************************************************************************/
+void evel_meas_latency_bucket_add(EVENT_MEASUREMENT * const measurement,
+                                  MEASUREMENT_LATENCY_BUCKET * const bucket);
+
+/**************************************************************************//**
+ * Add an additional Latency Distribution bucket to the Measurement.
+ *
+ * This function implements the previous API, purely for convenience.
+ *
+ * @param measurement   Pointer to the measurement.
+ * @param low_end       Low end of the bucket's range.
+ * @param high_end      High end of the bucket's range.
+ * @param count         Count of events in this bucket.
+ *****************************************************************************/
+void evel_measurement_latency_add(EVENT_MEASUREMENT * const measurement,
+                                  const double low_end,
+                                  const double high_end,
+                                  const int count);
+
+/**************************************************************************//**
+ * Create a new vNIC Use to be added to a Measurement event.
+ *
+ * @note    The mandatory fields on the ::MEASUREMENT_VNIC_PERFORMANCE must be supplied
+ *          to this factory function and are immutable once set. Optional
+ *          fields have explicit setter functions, but again values may only be
+ *          set once so that the ::MEASUREMENT_VNIC_PERFORMANCE has immutable
+ *          properties.
+ *
+ * @param vnic_id               ASCIIZ string with the vNIC's ID.
+ * @param val_suspect           True or false confidence in data.
+ *
+ * @returns pointer to the newly manufactured ::MEASUREMENT_VNIC_PERFORMANCE.
+ *          If the structure is not used it must be released using
+ *          ::evel_measurement_free_vnic_performance.
+ * @retval  NULL  Failed to create the vNIC Use.
+ *****************************************************************************/
+MEASUREMENT_VNIC_PERFORMANCE * evel_measurement_new_vnic_performance(char * const vnic_id, char * const val_suspect);
+
+/**************************************************************************//**
+ * Free a vNIC Use.
+ *
+ * Free off the ::MEASUREMENT_VNIC_PERFORMANCE supplied.  Will free all the contained
+ * allocated memory.
+ *
+ * @note It does not free the vNIC Use itself, since that may be part of a
+ * larger structure.
+ *****************************************************************************/
+void evel_measurement_free_vnic_performance(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance);
+
+/**************************************************************************//**
+ * Set the Accumulated Broadcast Packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_bcast_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_rx_bcast_pkt_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_bcast_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Broadcast Packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_bcast_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_rx_bcast_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_bcast_packets_delta);
+/**************************************************************************//**
+ * Set the Discarded Packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_discard_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_rx_discard_pkt_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_discard_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Discarded Packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_discard_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_rx_discard_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_discard_packets_delta);
+/**************************************************************************//**
+ * Set the Error Packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_error_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_rx_error_pkt_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_error_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Error Packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_error_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_rx_error_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_error_packets_delta);
+/**************************************************************************//**
+ * Set the Accumulated Multicast Packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_mcast_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_rx_mcast_pkt_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_mcast_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Multicast Packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_mcast_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_rx_mcast_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_mcast_packets_delta);
+/**************************************************************************//**
+ * Set the Accumulated Octets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_octets_acc
+ *****************************************************************************/
+void evel_vnic_performance_rx_octets_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_octets_acc);
+/**************************************************************************//**
+ * Set the Delta Octets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_octets_delta
+ *****************************************************************************/
+void evel_vnic_performance_rx_octets_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_octets_delta);
+/**************************************************************************//**
+ * Set the Accumulated Total Packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_total_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_rx_total_pkt_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_total_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Total Packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_total_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_rx_total_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_total_packets_delta);
+/**************************************************************************//**
+ * Set the Accumulated Unicast Packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_ucast_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_rx_ucast_pkt_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_ucast_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Unicast packets Received in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param recvd_ucast_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_rx_ucast_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double recvd_ucast_packets_delta);
+/**************************************************************************//**
+ * Set the Transmitted Broadcast Packets in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_bcast_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_tx_bcast_pkt_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_bcast_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Broadcast packets Transmitted in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_bcast_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_tx_bcast_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_bcast_packets_delta);
+/**************************************************************************//**
+ * Set the Transmitted Discarded Packets in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_discarded_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_tx_discarded_pkt_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_discarded_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Discarded packets Transmitted in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_discarded_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_tx_discarded_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_discarded_packets_delta);
+/**************************************************************************//**
+ * Set the Transmitted Errored Packets in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_error_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_tx_error_pkt_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_error_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Errored packets Transmitted in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_error_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_tx_error_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_error_packets_delta);
+/**************************************************************************//**
+ * Set the Transmitted Multicast Packets in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_mcast_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_tx_mcast_pkt_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_mcast_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Multicast packets Transmitted in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_mcast_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_tx_mcast_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_mcast_packets_delta);
+/**************************************************************************//**
+ * Set the Transmitted Octets in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_octets_acc
+ *****************************************************************************/
+void evel_vnic_performance_tx_octets_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_octets_acc);
+/**************************************************************************//**
+ * Set the Delta Octets Transmitted in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_octets_delta
+ *****************************************************************************/
+void evel_vnic_performance_tx_octets_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_octets_delta);
+/**************************************************************************//**
+ * Set the Transmitted Total Packets in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_total_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_tx_total_pkt_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_total_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Total Packets Transmitted in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_total_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_tx_total_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_total_packets_delta);
+/**************************************************************************//**
+ * Set the Transmitted Unicast Packets in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_ucast_packets_acc
+ *****************************************************************************/
+void evel_vnic_performance_tx_ucast_packets_acc_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_ucast_packets_acc);
+/**************************************************************************//**
+ * Set the Delta Octets Transmitted in measurement interval
+ * property of the vNIC performance.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param vnic_performance      Pointer to the vNIC Use.
+ * @param tx_ucast_packets_delta
+ *****************************************************************************/
+void evel_vnic_performance_tx_ucast_pkt_delta_set(MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance,
+                                    const double tx_ucast_packets_delta);
+
+/**************************************************************************//**
+ * Add an additional vNIC Use to the specified Measurement event.
+ *
+ * @param measurement   Pointer to the measurement.
+ * @param vnic_performance      Pointer to the vNIC Use to add.
+ *****************************************************************************/
+void evel_meas_vnic_performance_add(EVENT_MEASUREMENT * const measurement,
+                            MEASUREMENT_VNIC_PERFORMANCE * const vnic_performance);
+
+/**************************************************************************//**
+ * Add an additional vNIC usage record Measurement.
+ *
+ * This function implements the previous API, purely for convenience.
+ *
+ * The ID is null delimited ASCII string.  The library takes a copy so the
+ * caller does not have to preserve values after the function returns.
+ *
+ * @param measurement           Pointer to the measurement.
+ * @param vnic_id               ASCIIZ string with the vNIC's ID.
+ * @param valset                true or false confidence level
+ * @param recvd_bcast_packets_acc         Recieved broadcast packets
+ * @param recvd_bcast_packets_delta       Received delta broadcast packets
+ * @param recvd_discarded_packets_acc     Recieved discarded packets
+ * @param recvd_discarded_packets_delta   Received discarded delta packets
+ * @param recvd_error_packets_acc         Received error packets
+ * @param recvd_error_packets_delta,      Received delta error packets
+ * @param recvd_mcast_packets_acc         Received multicast packets
+ * @param recvd_mcast_packets_delta       Received delta multicast packets
+ * @param recvd_octets_acc                Received octets
+ * @param recvd_octets_delta              Received delta octets
+ * @param recvd_total_packets_acc         Received total packets
+ * @param recvd_total_packets_delta       Received delta total packets
+ * @param recvd_ucast_packets_acc         Received Unicast packets
+ * @param recvd_ucast_packets_delta       Received delta unicast packets
+ * @param tx_bcast_packets_acc            Transmitted broadcast packets
+ * @param tx_bcast_packets_delta          Transmitted delta broadcast packets
+ * @param tx_discarded_packets_acc        Transmitted packets discarded
+ * @param tx_discarded_packets_delta      Transmitted delta discarded packets
+ * @param tx_error_packets_acc            Transmitted error packets
+ * @param tx_error_packets_delta          Transmitted delta error packets
+ * @param tx_mcast_packets_acc            Transmitted multicast packets accumulated
+ * @param tx_mcast_packets_delta          Transmitted delta multicast packets
+ * @param tx_octets_acc                   Transmitted octets
+ * @param tx_octets_delta                 Transmitted delta octets
+ * @param tx_total_packets_acc            Transmitted total packets
+ * @param tx_total_packets_delta          Transmitted delta total packets
+ * @param tx_ucast_packets_acc            Transmitted Unicast packets
+ * @param tx_ucast_packets_delta          Transmitted delta Unicast packets
+ *****************************************************************************/
+void evel_measurement_vnic_performance_add(EVENT_MEASUREMENT * const measurement,
+                               char * const vnic_id,
+                               char * valset,
+                               double recvd_bcast_packets_acc,
+                               double recvd_bcast_packets_delta,
+                               double recvd_discarded_packets_acc,
+                               double recvd_discarded_packets_delta,
+                               double recvd_error_packets_acc,
+                               double recvd_error_packets_delta,
+                               double recvd_mcast_packets_acc,
+                               double recvd_mcast_packets_delta,
+                               double recvd_octets_acc,
+                               double recvd_octets_delta,
+                               double recvd_total_packets_acc,
+                               double recvd_total_packets_delta,
+                               double recvd_ucast_packets_acc,
+                               double recvd_ucast_packets_delta,
+                               double tx_bcast_packets_acc,
+                               double tx_bcast_packets_delta,
+                               double tx_discarded_packets_acc,
+                               double tx_discarded_packets_delta,
+                               double tx_error_packets_acc,
+                               double tx_error_packets_delta,
+                               double tx_mcast_packets_acc,
+                               double tx_mcast_packets_delta,
+                               double tx_octets_acc,
+                               double tx_octets_delta,
+                               double tx_total_packets_acc,
+                               double tx_total_packets_delta,
+                               double tx_ucast_packets_acc,
+                               double tx_ucast_packets_delta);
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   REPORT                                                                  */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+/**************************************************************************//**
+ * Create a new Report event.
+ *
+ * @note    The mandatory fields on the Report must be supplied to this
+ *          factory function and are immutable once set.  Optional fields have
+ *          explicit setter functions, but again values may only be set once so
+ *          that the Report has immutable properties.
+ *
+ * @param   measurement_interval
+ * @param event_name    Unique Event Name
+ * @param event_id    A universal identifier of the event for analysis etc
+ *
+ * @returns pointer to the newly manufactured ::EVENT_REPORT.  If the event is
+ *          not used (i.e. posted) it must be released using
+ *          ::evel_free_report.
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_REPORT * evel_new_report(double measurement_interval,const char* ev_name, const char *ev_id);
+
+/**************************************************************************//**
+ * Free a Report.
+ *
+ * Free off the Report supplied.  Will free all the contained allocated memory.
+ *
+ * @note It does not free the Report itself, since that may be part of a
+ * larger structure.
+ *****************************************************************************/
+void evel_free_report(EVENT_REPORT * event);
+
+/**************************************************************************//**
+ * Set the Event Type property of the Report.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param report Pointer to the Report.
+ * @param type        The Event Type to be set. ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_report_type_set(EVENT_REPORT * report, const char * const type);
+
+/**************************************************************************//**
+ * Add a Feature usage value name/value pair to the Report.
+ *
+ * The name is null delimited ASCII string.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param report          Pointer to the report.
+ * @param feature         ASCIIZ string with the feature's name.
+ * @param utilization     Utilization of the feature.
+ *****************************************************************************/
+void evel_report_feature_use_add(EVENT_REPORT * report,
+                                 char * feature,
+                                 int utilization);
+
+/**************************************************************************//**
+ * Add a Additional Measurement value name/value pair to the Report.
+ *
+ * The name is null delimited ASCII string.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param report   Pointer to the report.
+ * @param group    ASCIIZ string with the measurement group's name.
+ * @param name     ASCIIZ string containing the measurement's name.
+ * @param value    ASCIIZ string containing the measurement's value.
+ *****************************************************************************/
+void evel_report_custom_measurement_add(EVENT_REPORT * report,
+                                        const char * const group,
+                                        const char * const name,
+                                        const char * const value);
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   MOBILE_FLOW                                                             */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+/**************************************************************************//**
+ * Create a new Mobile Flow event.
+ *
+ * @note    The mandatory fields on the Mobile Flow must be supplied to this
+ *          factory function and are immutable once set.  Optional fields have
+ *          explicit setter functions, but again values may only be set once so
+ *          that the Mobile Flow has immutable properties.
+ *
+ * @param event_name    Unique Event Name
+ * @param event_id    A universal identifier of the event for analysis etc
+ * @param   flow_direction
+ * @param   gtp_per_flow_metrics
+ * @param   ip_protocol_type
+ * @param   ip_version
+ * @param   other_endpoint_ip_address
+ * @param   other_endpoint_port
+ * @param   reporting_endpoint_ip_addr
+ * @param   reporting_endpoint_port
+ *
+ * @returns pointer to the newly manufactured ::EVENT_MOBILE_FLOW.  If the
+ *          event is not used (i.e. posted) it must be released using
+ *          ::evel_free_mobile_flow.
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_MOBILE_FLOW * evel_new_mobile_flow(
+		      const char* ev_name, const char *ev_id,
+                      const char * const flow_direction,
+                      MOBILE_GTP_PER_FLOW_METRICS * gtp_per_flow_metrics,
+                      const char * const ip_protocol_type,
+                      const char * const ip_version,
+                      const char * const other_endpoint_ip_address,
+                      int other_endpoint_port,
+                      const char * const reporting_endpoint_ip_addr,
+                      int reporting_endpoint_port);
+
+/**************************************************************************//**
+ * Free a Mobile Flow.
+ *
+ * Free off the Mobile Flow supplied.  Will free all the contained allocated
+ * memory.
+ *
+ * @note It does not free the Mobile Flow itself, since that may be part of a
+ * larger structure.
+ *****************************************************************************/
+void evel_free_mobile_flow(EVENT_MOBILE_FLOW * event);
+
+/**************************************************************************//**
+ * Set the Event Type property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param type        The Event Type to be set. ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_mobile_flow_type_set(EVENT_MOBILE_FLOW * mobile_flow,
+                               const char * const type);
+
+/**************************************************************************//**
+ * Set the Application Type property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param type        The Application Type to be set. ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_mobile_flow_app_type_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                   const char * const type);
+
+/**************************************************************************//**
+ * Set the Application Protocol Type property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param type        The Application Protocol Type to be set. ASCIIZ string.
+ *                    The caller does not need to preserve the value once the
+ *                    function returns.
+ *****************************************************************************/
+void evel_mobile_flow_app_prot_type_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                        const char * const type);
+
+/**************************************************************************//**
+ * Set the Application Protocol Version property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param version     The Application Protocol Version to be set. ASCIIZ
+ *                    string.  The caller does not need to preserve the value
+ *                    once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_app_prot_ver_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                       const char * const version);
+
+/**************************************************************************//**
+ * Set the CID property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param cid         The CID to be set. ASCIIZ string.  The caller does not
+ *                    need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_cid_set(EVENT_MOBILE_FLOW * mobile_flow,
+                              const char * const cid);
+
+/**************************************************************************//**
+ * Set the Connection Type property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param type        The Connection Type to be set. ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_mobile_flow_con_type_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                   const char * const type);
+
+/**************************************************************************//**
+ * Set the ECGI property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param ecgi        The ECGI to be set. ASCIIZ string.  The caller does not
+ *                    need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_ecgi_set(EVENT_MOBILE_FLOW * mobile_flow,
+                               const char * const ecgi);
+
+/**************************************************************************//**
+ * Set the GTP Protocol Type property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param type        The GTP Protocol Type to be set. ASCIIZ string.  The
+ *                    caller does not need to preserve the value once the
+ *                    function returns.
+ *****************************************************************************/
+void evel_mobile_flow_gtp_prot_type_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                        const char * const type);
+
+/**************************************************************************//**
+ * Set the GTP Protocol Version property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param version     The GTP Protocol Version to be set. ASCIIZ string.  The
+ *                    caller does not need to preserve the value once the
+ *                    function returns.
+ *****************************************************************************/
+void evel_mobile_flow_gtp_prot_ver_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                       const char * const version);
+
+/**************************************************************************//**
+ * Set the HTTP Header property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param header      The HTTP header to be set. ASCIIZ string. The caller does
+ *                    not need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_http_header_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                      const char * const header);
+
+/**************************************************************************//**
+ * Set the IMEI property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param imei        The IMEI to be set. ASCIIZ string.  The caller does not
+ *                    need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_imei_set(EVENT_MOBILE_FLOW * mobile_flow,
+                               const char * const imei);
+
+/**************************************************************************//**
+ * Set the IMSI property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param imsi        The IMSI to be set. ASCIIZ string.  The caller does not
+ *                    need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_imsi_set(EVENT_MOBILE_FLOW * mobile_flow,
+                               const char * const imsi);
+
+/**************************************************************************//**
+ * Set the LAC property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param lac         The LAC to be set. ASCIIZ string.  The caller does not
+ *                    need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_lac_set(EVENT_MOBILE_FLOW * mobile_flow,
+                              const char * const lac);
+
+/**************************************************************************//**
+ * Set the MCC property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param mcc         The MCC to be set. ASCIIZ string.  The caller does not
+ *                    need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_mcc_set(EVENT_MOBILE_FLOW * mobile_flow,
+                              const char * const mcc);
+
+/**************************************************************************//**
+ * Set the MNC property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param mnc         The MNC to be set. ASCIIZ string.  The caller does not
+ *                    need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_mnc_set(EVENT_MOBILE_FLOW * mobile_flow,
+                              const char * const mnc);
+
+/**************************************************************************//**
+ * Set the MSISDN property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param msisdn      The MSISDN to be set. ASCIIZ string.  The caller does not
+ *                    need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_msisdn_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                 const char * const msisdn);
+
+/**************************************************************************//**
+ * Set the Other Functional Role property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param role        The Other Functional Role to be set. ASCIIZ string. The
+ *                    caller does not need to preserve the value once the
+ *                    function returns.
+ *****************************************************************************/
+void evel_mobile_flow_other_func_role_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                          const char * const role);
+
+/**************************************************************************//**
+ * Set the RAC property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param rac         The RAC to be set. ASCIIZ string.  The caller does not
+ *                    need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_rac_set(EVENT_MOBILE_FLOW * mobile_flow,
+                              const char * const rac);
+
+/**************************************************************************//**
+ * Set the Radio Access Technology property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param tech        The Radio Access Technology to be set. ASCIIZ string. The
+ *                    caller does not need to preserve the value once the
+ *                    function returns.
+ *****************************************************************************/
+void evel_mobile_flow_radio_acc_tech_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                         const char * const tech);
+
+/**************************************************************************//**
+ * Set the SAC property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param sac         The SAC to be set. ASCIIZ string.  The caller does not
+ *                    need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_sac_set(EVENT_MOBILE_FLOW * mobile_flow,
+                              const char * const sac);
+
+/**************************************************************************//**
+ * Set the Sampling Algorithm property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param algorithm   The Sampling Algorithm to be set.
+ *****************************************************************************/
+void evel_mobile_flow_samp_alg_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                   int algorithm);
+
+/**************************************************************************//**
+ * Set the TAC property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param tac         The TAC to be set. ASCIIZ string.  The caller does not
+ *                    need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_tac_set(EVENT_MOBILE_FLOW * mobile_flow,
+                              const char * const tac);
+
+/**************************************************************************//**
+ * Set the Tunnel ID property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param tunnel_id   The Tunnel ID to be set. ASCIIZ string.  The caller does
+ *                    not need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_tunnel_id_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                    const char * const tunnel_id);
+
+/**************************************************************************//**
+ * Set the VLAN ID property of the Mobile Flow.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param mobile_flow Pointer to the Mobile Flow.
+ * @param vlan_id     The VLAN ID to be set. ASCIIZ string.  The caller does
+ *                    not need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_mobile_flow_vlan_id_set(EVENT_MOBILE_FLOW * mobile_flow,
+                                  const char * const vlan_id);
+
+/**************************************************************************//**
+ * Create a new Mobile GTP Per Flow Metrics.
+ *
+ * @note    The mandatory fields on the Mobile GTP Per Flow Metrics must be
+ *          supplied to this factory function and are immutable once set.
+ *          Optional fields have explicit setter functions, but again values
+ *          may only be set once so that the Mobile GTP Per Flow Metrics has
+ *          immutable properties.
+ *
+ * @param   avg_bit_error_rate
+ * @param   avg_packet_delay_variation
+ * @param   avg_packet_latency
+ * @param   avg_receive_throughput
+ * @param   avg_transmit_throughput
+ * @param   flow_activation_epoch
+ * @param   flow_activation_microsec
+ * @param   flow_deactivation_epoch
+ * @param   flow_deactivation_microsec
+ * @param   flow_deactivation_time
+ * @param   flow_status
+ * @param   max_packet_delay_variation
+ * @param   num_activation_failures
+ * @param   num_bit_errors
+ * @param   num_bytes_received
+ * @param   num_bytes_transmitted
+ * @param   num_dropped_packets
+ * @param   num_l7_bytes_received
+ * @param   num_l7_bytes_transmitted
+ * @param   num_lost_packets
+ * @param   num_out_of_order_packets
+ * @param   num_packet_errors
+ * @param   num_packets_received_excl_retrans
+ * @param   num_packets_received_incl_retrans
+ * @param   num_packets_transmitted_incl_retrans
+ * @param   num_retries
+ * @param   num_timeouts
+ * @param   num_tunneled_l7_bytes_received
+ * @param   round_trip_time
+ * @param   time_to_first_byte
+ *
+ * @returns pointer to the newly manufactured ::MOBILE_GTP_PER_FLOW_METRICS.
+ *          If the structure is not used it must be released using
+ *          ::evel_free_mobile_gtp_flow_metrics.
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+MOBILE_GTP_PER_FLOW_METRICS * evel_new_mobile_gtp_flow_metrics(
+                                      double avg_bit_error_rate,
+                                      double avg_packet_delay_variation,
+                                      int avg_packet_latency,
+                                      int avg_receive_throughput,
+                                      int avg_transmit_throughput,
+                                      int flow_activation_epoch,
+                                      int flow_activation_microsec,
+                                      int flow_deactivation_epoch,
+                                      int flow_deactivation_microsec,
+                                      time_t flow_deactivation_time,
+                                      const char * const flow_status,
+                                      int max_packet_delay_variation,
+                                      int num_activation_failures,
+                                      int num_bit_errors,
+                                      int num_bytes_received,
+                                      int num_bytes_transmitted,
+                                      int num_dropped_packets,
+                                      int num_l7_bytes_received,
+                                      int num_l7_bytes_transmitted,
+                                      int num_lost_packets,
+                                      int num_out_of_order_packets,
+                                      int num_packet_errors,
+                                      int num_packets_received_excl_retrans,
+                                      int num_packets_received_incl_retrans,
+                                      int num_packets_transmitted_incl_retrans,
+                                      int num_retries,
+                                      int num_timeouts,
+                                      int num_tunneled_l7_bytes_received,
+                                      int round_trip_time,
+                                      int time_to_first_byte);
+
+/**************************************************************************//**
+ * Free a Mobile GTP Per Flow Metrics.
+ *
+ * Free off the Mobile GTP Per Flow Metrics supplied.  Will free all the
+ * contained allocated memory.
+ *
+ * @note It does not free the Mobile GTP Per Flow Metrics itself, since that
+ * may be part of a larger structure.
+ *****************************************************************************/
+void evel_free_mobile_gtp_flow_metrics(MOBILE_GTP_PER_FLOW_METRICS * metrics);
+
+/**************************************************************************//**
+ * Set the Duration of Connection Failed Status property of the Mobile GTP Per
+ * Flow Metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param duration    The Duration of Connection Failed Status to be set.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_dur_con_fail_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         int duration);
+
+/**************************************************************************//**
+ * Set the Duration of Tunnel Failed Status property of the Mobile GTP Per Flow
+ * Metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param duration    The Duration of Tunnel Failed Status to be set.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_dur_tun_fail_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         int duration);
+
+/**************************************************************************//**
+ * Set the Activated By property of the Mobile GTP Per Flow metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param act_by      The Activated By to be set.  ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_act_by_set(MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                        const char * const act_by);
+
+/**************************************************************************//**
+ * Set the Activation Time property of the Mobile GTP Per Flow metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param act_time    The Activation Time to be set.  ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_act_time_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         time_t act_time);
+
+/**************************************************************************//**
+ * Set the Deactivated By property of the Mobile GTP Per Flow metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param deact_by    The Deactivated By to be set.  ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_deact_by_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         const char * const deact_by);
+
+/**************************************************************************//**
+ * Set the GTP Connection Status property of the Mobile GTP Per Flow metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param status      The GTP Connection Status to be set.  ASCIIZ string. The
+ *                    caller does not need to preserve the value once the
+ *                    function returns.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_con_status_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         const char * const status);
+
+/**************************************************************************//**
+ * Set the GTP Tunnel Status property of the Mobile GTP Per Flow metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param status      The GTP Tunnel Status to be set.  ASCIIZ string. The
+ *                    caller does not need to preserve the value once the
+ *                    function returns.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_tun_status_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         const char * const status);
+
+/**************************************************************************//**
+ * Set an IP Type-of-Service count property of the Mobile GTP Per Flow metrics.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param index       The index of the IP Type-of-Service.
+ * @param count       The count.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_iptos_set(MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                       int index,
+                                       int count);
+
+/**************************************************************************//**
+ * Set the Large Packet Round-Trip Time property of the Mobile GTP Per Flow
+ * Metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param rtt         The Large Packet Round-Trip Time to be set.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_large_pkt_rtt_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         int rtt);
+
+/**************************************************************************//**
+ * Set the Large Packet Threshold property of the Mobile GTP Per Flow Metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param threshold   The Large Packet Threshold to be set.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_large_pkt_thresh_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         double threshold);
+
+/**************************************************************************//**
+ * Set the Max Receive Bit Rate property of the Mobile GTP Per Flow Metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param rate        The Max Receive Bit Rate to be set.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_max_rcv_bit_rate_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         int rate);
+
+/**************************************************************************//**
+ * Set the Max Transmit Bit Rate property of the Mobile GTP Per Flow Metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param rate        The Max Transmit Bit Rate to be set.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_max_trx_bit_rate_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         int rate);
+
+/**************************************************************************//**
+ * Set the Number of GTP Echo Failures property of the Mobile GTP Per Flow
+ * Metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param num         The Number of GTP Echo Failures to be set.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_num_echo_fail_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         int num);
+
+/**************************************************************************//**
+ * Set the Number of GTP Tunnel Errors property of the Mobile GTP Per Flow
+ * Metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param num         The Number of GTP Tunnel Errors to be set.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_num_tun_fail_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         int num);
+
+/**************************************************************************//**
+ * Set the Number of HTTP Errors property of the Mobile GTP Per Flow Metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics     Pointer to the Mobile GTP Per Flow Metrics.
+ * @param num         The Number of HTTP Errors to be set.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_num_http_errors_set(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         int num);
+
+/**************************************************************************//**
+ * Add a TCP flag count to the metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics       Pointer to the Mobile GTP Per Flow Metrics.
+ * @param tcp_flag      The TCP flag count to be updated.
+ * @param count         The associated flag count.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_tcp_flag_count_add(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         const EVEL_TCP_FLAGS tcp_flag,
+                                         const int count);
+
+/**************************************************************************//**
+ * Add a QCI COS count to the metrics.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param metrics       Pointer to the Mobile GTP Per Flow Metrics.
+ * @param qci_cos       The QCI COS count to be updated.
+ * @param count         The associated QCI COS count.
+ *****************************************************************************/
+void evel_mobile_gtp_metrics_qci_cos_count_add(
+                                         MOBILE_GTP_PER_FLOW_METRICS * metrics,
+                                         const EVEL_QCI_COS_TYPES qci_cos,
+                                         const int count);
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   SIGNALING                                                               */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+/**************************************************************************//**
+ * Create a new Signaling event.
+ *
+ * @note    The mandatory fields on the Signaling must be supplied to
+ *          this factory function and are immutable once set.  Optional fields
+ *          have explicit setter functions, but again values may only be set
+ *          once so that the event has immutable properties.
+ * @param event_name    Unique Event Name
+ * @param event_id    A universal identifier of the event for analysis etc
+ * @param vendor_name   The vendor id to encode in the event vnf field.
+ * @param module        The module to encode in the event.
+ * @param vnfname       The Virtual network function to encode in the event.
+ * @returns pointer to the newly manufactured ::EVENT_SIGNALING.  If the event
+ *          is not used (i.e. posted) it must be released using
+ *          ::evel_free_signaling.
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_SIGNALING * evel_new_signaling(const char* ev_name, const char *ev_id,
+				     const char * const vendor_name,
+                                     const char * const correlator,
+				     const char * const local_ip_address,
+				     const char * const local_port,
+				     const char * const remote_ip_address,
+				     const char * const remote_port);
+
+/**************************************************************************//**
+ * Free a Signaling event.
+ *
+ * Free off the event supplied.  Will free all the contained allocated memory.
+ *
+ * @note It does not free the event itself, since that may be part of a larger
+ * structure.
+ *****************************************************************************/
+void evel_free_signaling(EVENT_SIGNALING * const event);
+
+/**************************************************************************//**
+ * Set the Event Type property of the Signaling event.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param event         Pointer to the Signaling event.
+ * @param type          The Event Type to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_signaling_type_set(EVENT_SIGNALING * const event,
+                             const char * const type);
+
+/**************************************************************************//**
+ * Add an additional value name/value pair to the SIP signaling.
+ *
+ * The name and value are null delimited ASCII strings.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param event     Pointer to the fault.
+ * @param name      ASCIIZ string with the attribute's name.  The caller
+ *                  does not need to preserve the value once the function
+ *                  returns.
+ * @param value     ASCIIZ string with the attribute's value.  The caller
+ *                  does not need to preserve the value once the function
+ *                  returns.
+ *****************************************************************************/
+void evel_signaling_addl_info_add(EVENT_SIGNALING * event, char * name, char * value);
+
+/**************************************************************************//**
+ * Set the Correlator property of the Signaling event.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param event         Pointer to the Signaling event.
+ * @param correlator    The correlator to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_signaling_correlator_set(EVENT_SIGNALING * const event,
+                                   const char * const correlator);
+
+/**************************************************************************//**
+ * Set the Local Ip Address property of the Signaling event.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param event         Pointer to the Signaling event.
+ * @param local_ip_address
+ *                      The Local Ip Address to be set. ASCIIZ string. The
+ *                      caller does not need to preserve the value once the
+ *                      function returns.
+ *****************************************************************************/
+void evel_signaling_local_ip_address_set(EVENT_SIGNALING * const event,
+                                         const char * const local_ip_address);
+
+/**************************************************************************//**
+ * Set the Local Port property of the Signaling event.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param event         Pointer to the Signaling event.
+ * @param local_port    The Local Port to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_signaling_local_port_set(EVENT_SIGNALING * const event,
+                                   const char * const local_port);
+
+/**************************************************************************//**
+ * Set the Remote Ip Address property of the Signaling event.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param event         Pointer to the Signaling event.
+ * @param remote_ip_address
+ *                      The Remote Ip Address to be set. ASCIIZ string. The
+ *                      caller does not need to preserve the value once the
+ *                      function returns.
+ *****************************************************************************/
+void evel_signaling_remote_ip_address_set(EVENT_SIGNALING * const event,
+                                         const char * const remote_ip_address);
+
+/**************************************************************************//**
+ * Set the Remote Port property of the Signaling event.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param event         Pointer to the Signaling event.
+ * @param remote_port   The Remote Port to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_signaling_remote_port_set(EVENT_SIGNALING * const event,
+                                    const char * const remote_port);
+/**************************************************************************//**
+ * Set the Vendor module property of the Signaling event.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param event         Pointer to the Signaling event.
+ * @param modulename    The module name to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_signaling_vnfmodule_name_set(EVENT_SIGNALING * const event,
+                                    const char * const module_name);
+/**************************************************************************//**
+ * Set the Vendor module property of the Signaling event.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param event         Pointer to the Signaling event.
+ * @param vnfname       The Virtual Network function to be set. ASCIIZ string.
+ *                      The caller does not need to preserve the value once
+ *                      the function returns.
+ *****************************************************************************/
+void evel_signaling_vnfname_set(EVENT_SIGNALING * const event,
+                                    const char * const vnfname);
+
+/**************************************************************************//**
+ * Set the Compressed SIP property of the Signaling event.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param event         Pointer to the Signaling event.
+ * @param compressed_sip
+ *                      The Compressed SIP to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_signaling_compressed_sip_set(EVENT_SIGNALING * const event,
+                                       const char * const compressed_sip);
+
+/**************************************************************************//**
+ * Set the Summary SIP property of the Signaling event.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param event         Pointer to the Signaling event.
+ * @param summary_sip   The Summary SIP to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_signaling_summary_sip_set(EVENT_SIGNALING * const event,
+                                    const char * const summary_sip);
+
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   STATE CHANGE                                                            */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+/**************************************************************************//**
+ * Create a new State Change event.
+ *
+ * @note    The mandatory fields on the Syslog must be supplied to this factory
+ *          function and are immutable once set.  Optional fields have explicit
+ *          setter functions, but again values may only be set once so that the
+ *          Syslog has immutable properties.
+ *
+ * @param event_name    Unique Event Name
+ * @param event_id    A universal identifier of the event for analysis etc
+ * @param new_state     The new state of the reporting entity.
+ * @param old_state     The old state of the reporting entity.
+ * @param interface     The card or port name of the reporting entity.
+ *
+ * @returns pointer to the newly manufactured ::EVENT_STATE_CHANGE.  If the
+ *          event is not used it must be released using
+ *          ::evel_free_state_change
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_STATE_CHANGE * evel_new_state_change(const char* ev_name, const char *ev_id,
+					   const EVEL_ENTITY_STATE new_state,
+                                           const EVEL_ENTITY_STATE old_state,
+                                           const char * const interface);
+
+/**************************************************************************//**
+ * Free a State Change.
+ *
+ * Free off the State Change supplied.  Will free all the contained allocated
+ * memory.
+ *
+ * @note It does not free the State Change itself, since that may be part of a
+ * larger structure.
+ *****************************************************************************/
+void evel_free_state_change(EVENT_STATE_CHANGE * const state_change);
+
+/**************************************************************************//**
+ * Set the Event Type property of the State Change.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param state_change  Pointer to the ::EVENT_STATE_CHANGE.
+ * @param type          The Event Type to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_state_change_type_set(EVENT_STATE_CHANGE * const state_change,
+                                const char * const type);
+
+/**************************************************************************//**
+ * Add an additional field name/value pair to the State Change.
+ *
+ * The name and value are null delimited ASCII strings.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param state_change  Pointer to the ::EVENT_STATE_CHANGE.
+ * @param name          ASCIIZ string with the attribute's name.  The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ * @param value         ASCIIZ string with the attribute's value.  The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_state_change_addl_field_add(EVENT_STATE_CHANGE * const state_change,
+                                      const char * const name,
+                                      const char * const value);
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   SYSLOG                                                                  */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+/**************************************************************************//**
+ * Create a new syslog event.
+ *
+ * @note    The mandatory fields on the Syslog must be supplied to this factory
+ *          function and are immutable once set.  Optional fields have explicit
+ *          setter functions, but again values may only be set once so that the
+ *          Syslog has immutable properties.
+ *
+ * @param event_name    Unique Event Name
+ * @param event_id    A universal identifier of the event for analysis etc
+ * @param   event_source_type
+ * @param   syslog_msg
+ * @param   syslog_tag
+ * @param   version
+ *
+ * @returns pointer to the newly manufactured ::EVENT_SYSLOG.  If the event is
+ *          not used it must be released using ::evel_free_syslog
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_SYSLOG * evel_new_syslog(const char* ev_name, const char *ev_id,
+				EVEL_SOURCE_TYPES event_source_type,
+                               const char * const syslog_msg,
+                               const char * const syslog_tag);
+
+/**************************************************************************//**
+ * Set the Event Type property of the Syslog.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param syslog      Pointer to the syslog.
+ * @param type        The Event Type to be set. ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_syslog_type_set(EVENT_SYSLOG * syslog,
+                          const char * const type);
+
+/**************************************************************************//**
+ * Free a Syslog.
+ *
+ * Free off the Syslog supplied.  Will free all the contained allocated memory.
+ *
+ * @note It does not free the Syslog itself, since that may be part of a
+ * larger structure.
+ *****************************************************************************/
+void evel_free_syslog(EVENT_SYSLOG * event);
+
+/**************************************************************************//**
+ * Add an additional field name/value pair to the Syslog.
+ *
+ * The name and value are null delimited ASCII strings.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param syslog    Pointer to the syslog.
+ * @param name      ASCIIZ string with the attribute's name.  The caller
+ *                  does not need to preserve the value once the function
+ *                  returns.
+ * @param value     ASCIIZ string with the attribute's value.  The caller
+ *                  does not need to preserve the value once the function
+ *                  returns.
+ *****************************************************************************/
+void evel_syslog_addl_field_add(EVENT_SYSLOG * syslog,
+                                char * name,
+                                char * value);
+
+/**************************************************************************//**
+ * Set the Event Source Host property of the Syslog.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param syslog      Pointer to the Syslog.
+ * @param host        The Event Source Host to be set.  ASCIIZ string. The
+ *                    caller does not need to preserve the value once the
+ *                    function returns.
+ *****************************************************************************/
+void evel_syslog_event_source_host_set(EVENT_SYSLOG * syslog,
+                                       const char * const host);
+
+/**************************************************************************//**
+ * Set the Syslog Facility property of the Syslog.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param syslog      Pointer to the Syslog.
+ * @param facility    The Syslog Facility to be set.  ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_syslog_facility_set(EVENT_SYSLOG * syslog,
+                              EVEL_SYSLOG_FACILITIES facility);
+
+/**************************************************************************//**
+ * Set the Process property of the Syslog.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param syslog      Pointer to the Syslog.
+ * @param proc        The Process to be set.  ASCIIZ string. The caller does
+ *                    not need to preserve the value once the function returns.
+ *****************************************************************************/
+void evel_syslog_proc_set(EVENT_SYSLOG * syslog, const char * const proc);
+
+/**************************************************************************//**
+ * Set the Process ID property of the Syslog.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param syslog      Pointer to the Syslog.
+ * @param proc_id     The Process ID to be set.
+ *****************************************************************************/
+void evel_syslog_proc_id_set(EVENT_SYSLOG * syslog, int proc_id);
+
+/**************************************************************************//**
+ * Set the Version property of the Syslog.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param syslog      Pointer to the Syslog.
+ * @param version     The Version to be set.
+ *****************************************************************************/
+void evel_syslog_version_set(EVENT_SYSLOG * syslog, int version);
+
+/**************************************************************************//**
+ * Set the Structured Data property of the Syslog.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param syslog      Pointer to the Syslog.
+ * @param s_data      The Structured Data to be set.  ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_syslog_s_data_set(EVENT_SYSLOG * syslog, const char * const s_data);
+
+/**************************************************************************//**
+ * Set the Structured SDID property of the Syslog.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param syslog     Pointer to the Syslog.
+ * @param sdid     The Structured Data to be set. ASCIIZ string. name@number
+ *                 Caller does not need to preserve the value once the function
+ *                   returns.
+ *****************************************************************************/
+void evel_syslog_sdid_set(EVENT_SYSLOG * syslog, const char * const sdid);
+
+/**************************************************************************//**
+ * Set the Structured Severity property of the Syslog.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param syslog     Pointer to the Syslog.
+ * @param sdid     The Structured Data to be set. ASCIIZ string. 
+ *                 Caller does not need to preserve the value once the function
+ *                   returns.
+ *****************************************************************************/
+void evel_syslog_severity_set(EVENT_SYSLOG * syslog, const char * const severty);
+
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   OTHER                                                                   */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+/**************************************************************************//**
+ * Create a new other event.
+ *
+ * @param event_name    Unique Event Name
+ * @param event_id    A universal identifier of the event for analysis etc
+ *
+ * @returns pointer to the newly manufactured ::EVENT_OTHER.  If the event is
+ *          not used it must be released using ::evel_free_other.
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_OTHER * evel_new_other(const char* ev_name, const char *ev_id);
+
+/**************************************************************************//**
+ * Free an Other.
+ *
+ * Free off the Other supplied.  Will free all the contained allocated memory.
+ *
+ * @note It does not free the Other itself, since that may be part of a
+ * larger structure.
+ *****************************************************************************/
+void evel_free_other(EVENT_OTHER * event);
+
+/**************************************************************************//**
+ * Set the Event Type property of the Other.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param other       Pointer to the Other.
+ * @param type        The Event Type to be set. ASCIIZ string. The caller
+ *                    does not need to preserve the value once the function
+ *                    returns.
+ *****************************************************************************/
+void evel_other_type_set(EVENT_OTHER * other,
+                         const char * const type);
+
+/**************************************************************************//**
+ * Add a value name/value pair to the Other.
+ *
+ * The name and value are null delimited ASCII strings.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param other     Pointer to the Other.
+ * @param name      ASCIIZ string with the attribute's name.
+ * @param value     ASCIIZ string with the attribute's value.
+ *****************************************************************************/
+void evel_other_field_add(EVENT_OTHER * other,
+                          char * name,
+                          char * value);
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   THROTTLING                                                              */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+/**************************************************************************//**
+ * Return the current measurement interval provided by the Event Listener.
+ *
+ * @returns The current measurement interval
+ * @retval  EVEL_MEASUREMENT_INTERVAL_UKNOWN (0) - interval has not been
+ *          specified
+ *****************************************************************************/
+int evel_get_measurement_interval();
+
+/*****************************************************************************/
+/* Supported Report version.                                                 */
+/*****************************************************************************/
+#define EVEL_VOICEQ_MAJOR_VERSION 1
+#define EVEL_VOICEQ_MINOR_VERSION 1
+
+/**************************************************************************//**
+ * End of Call Voice Quality Metrices
+ * JSON equivalent field: endOfCallVqmSummaries
+ *****************************************************************************/
+typedef struct end_of_call_vqm_summaries {
+	/***************************************************************************/
+	/* Mandatory fields                                                        */
+	/***************************************************************************/
+	char* adjacencyName;
+	char* endpointDescription;
+
+	/***************************************************************************/
+	/* Optional fields                                                         */
+	/***************************************************************************/
+	EVEL_OPTION_INT endpointJitter;
+	EVEL_OPTION_INT endpointRtpOctetsDiscarded;
+	EVEL_OPTION_INT endpointRtpOctetsReceived;
+	EVEL_OPTION_INT endpointRtpOctetsSent;
+	EVEL_OPTION_INT endpointRtpPacketsDiscarded;
+	EVEL_OPTION_INT endpointRtpPacketsReceived;
+	EVEL_OPTION_INT endpointRtpPacketsSent;
+	EVEL_OPTION_INT localJitter;
+	EVEL_OPTION_INT localRtpOctetsDiscarded;
+	EVEL_OPTION_INT localRtpOctetsReceived;
+	EVEL_OPTION_INT localRtpOctetsSent;
+	EVEL_OPTION_INT localRtpPacketsDiscarded;
+	EVEL_OPTION_INT localRtpPacketsReceived;
+	EVEL_OPTION_INT localRtpPacketsSent;
+	EVEL_OPTION_INT mosCqe;
+	EVEL_OPTION_INT packetsLost;
+	EVEL_OPTION_INT packetLossPercent;
+	EVEL_OPTION_INT rFactor;
+	EVEL_OPTION_INT roundTripDelay;
+
+} END_OF_CALL_VOICE_QUALITY_METRICS;
+
+/**************************************************************************//**
+* Voice QUality.
+* JSON equivalent field: voiceQualityFields
+*****************************************************************************/
+
+typedef struct event_voiceQuality {
+	/***************************************************************************/
+	/* Header and version                                                      */
+	/***************************************************************************/
+	EVENT_HEADER header;
+	int major_version;
+	int minor_version;
+
+	/***************************************************************************/
+	/* Mandatory fields                                                        */
+	/***************************************************************************/
+	
+	char *calleeSideCodec;
+	char *callerSideCodec;
+	char *correlator;
+	char *midCallRtcp;
+	VENDOR_VNFNAME_FIELD vendorVnfNameFields;
+	END_OF_CALL_VOICE_QUALITY_METRICS *endOfCallVqmSummaries;
+
+	/***************************************************************************/
+	/* Optional fields                                                         */
+	/***************************************************************************/
+	EVEL_OPTION_STRING phoneNumber;
+	DLIST additionalInformation;
+
+} EVENT_VOICE_QUALITY;
+/**************************************************************************//**
+ * Voice Quality Additional Info.
+ * JSON equivalent field: additionalInformation
+ *****************************************************************************/
+typedef struct voice_quality_additional_info {
+  char * name;
+  char * value;
+} VOICE_QUALITY_ADDL_INFO;
+
+/**************************************************************************//**
+ * Create a new voice quality event.
+ *
+ * @note    The mandatory fields on the Voice Quality must be supplied to this 
+ *          factory function and are immutable once set.  Optional fields have 
+ *          explicit setter functions, but again values may only be set once 
+ *          so that the Voice Quality has immutable properties.
+ * @param event_name    Unique Event Name
+ * @param event_id    A universal identifier of the event for analysis etc
+ * @param   calleeSideCodec			Callee codec for the call.
+ * @param   callerSideCodec			Caller codec for the call.
+ * @param   correlator				Constant across all events on this call.
+ * @param   midCallRtcp				Base64 encoding of the binary RTCP data
+ *									(excluding Eth/IP/UDP headers).
+ * @param   vendorVnfNameFields		Vendor, VNF and VfModule names.
+ * @returns pointer to the newly manufactured ::EVENT_VOICE_QUALITY.  If the 
+ *          event is not used (i.e. posted) it must be released using
+			::evel_free_voice_quality.
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_VOICE_QUALITY * evel_new_voice_quality(const char* ev_name, const char *ev_id,
+	const char * const calleeSideCodec,
+	const char * const callerSideCodec, const char * const correlator,
+	const char * const midCallRtcp, const char * const vendorVnfNameFields);
+
+/**************************************************************************//**
+ * Set the Callee side codec for Call for domain Voice Quality
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param voiceQuality				Pointer to the Voice Quality Event.
+ * @param calleeCodecForCall		The Callee Side Codec to be set.  ASCIIZ 
+ *									string. The caller does not need to 
+ *									preserve the value once the function
+ *									returns.
+ *****************************************************************************/
+void evel_voice_quality_callee_codec_set(EVENT_VOICE_QUALITY * voiceQuality,
+									const char * const calleeCodecForCall);
+
+/**************************************************************************//**
+ * Set the Caller side codec for Call for domain Voice Quality
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param voiceQuality				Pointer to the Voice Quality Event.
+ * @param callerCodecForCall		The Caller Side Codec to be set.  ASCIIZ 
+ *									string. The caller does not need to 
+ *									preserve the value once the function
+ *									returns.
+ *****************************************************************************/
+void evel_voice_quality_caller_codec_set(EVENT_VOICE_QUALITY * voiceQuality,
+									const char * const callerCodecForCall);
+
+/**************************************************************************//**
+ * Set the correlator for domain Voice Quality
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param voiceQuality				Pointer to the Voice Quality Event.
+ * @param correlator				The correlator value to be set.  ASCIIZ 
+ *									string. The caller does not need to 
+ *									preserve the value once the function
+ *									returns.
+ *****************************************************************************/
+void evel_voice_quality_correlator_set(EVENT_VOICE_QUALITY * voiceQuality,
+									const char * const vCorrelator);
+
+/**************************************************************************//**
+ * Set the RTCP Call Data for domain Voice Quality
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param voiceQuality				Pointer to the Voice Quality Event.
+ * @param rtcpCallData		        The RTCP Call Data to be set.  ASCIIZ 
+ *									string. The caller does not need to 
+ *									preserve the value once the function
+ *									returns.
+ *****************************************************************************/
+void evel_voice_quality_rtcp_data_set(EVENT_VOICE_QUALITY * voiceQuality,
+									const char * const rtcpCallData);
+
+/**************************************************************************//**
+ * Set the Vendor VNF Name fields for domain Voice Quality
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param voiceQuality				Pointer to the Voice Quality Event.
+ * @param nameFields		        The Vendor, VNF and VfModule names to be set.   
+ *									ASCIIZ string. The caller does not need to 
+ *									preserve the value once the function
+ *									returns.
+ *****************************************************************************/
+void evel_voice_quality_name_fields_set(EVENT_VOICE_QUALITY * voiceQuality,
+									const char * const nameFields);
+
+/**************************************************************************//**
+ * Add an End of Call Voice Quality Metrices
+
+ * The adjacencyName and endpointDescription is null delimited ASCII string.  
+ * The library takes a copy so the caller does not have to preserve values
+ * after the function returns.
+ *
+ * @param voiceQuality     Pointer to the measurement.
+ * @param adjacencyName						Adjacency name
+ * @param endpointDescription				Enumeration: ‘Caller’, ‘Callee’.
+ * @param endpointJitter					Endpoint jitter
+ * @param endpointRtpOctetsDiscarded        Endpoint RTP octets discarded.
+ * @param endpointRtpOctetsReceived			Endpoint RTP octets received.
+ * @param endpointRtpOctetsSent				Endpoint RTP octets sent
+ * @param endpointRtpPacketsDiscarded		Endpoint RTP packets discarded.
+ * @param endpointRtpPacketsReceived		Endpoint RTP packets received.
+ * @param endpointRtpPacketsSent			Endpoint RTP packets sent.
+ * @param localJitter						Local jitter.
+ * @param localRtpOctetsDiscarded			Local RTP octets discarded.
+ * @param localRtpOctetsReceived			Local RTP octets received.
+ * @param localRtpOctetsSent				Local RTP octets sent.
+ * @param localRtpPacketsDiscarded			Local RTP packets discarded.
+ * @param localRtpPacketsReceived			Local RTP packets received.
+ * @param localRtpPacketsSent				Local RTP packets sent.
+ * @param mosCqe							Decimal range from 1 to 5
+ *											(1 decimal place)
+ * @param packetsLost						No	Packets lost
+ * @param packetLossPercent					Calculated percentage packet loss 
+ * @param rFactor							rFactor from 0 to 100
+ * @param roundTripDelay					Round trip delay in milliseconds
+ *****************************************************************************/
+void evel_voice_quality_end_metrics_add(EVENT_VOICE_QUALITY * voiceQuality,
+	const char * adjacencyName, EVEL_SERVICE_ENDPOINT_DESC endpointDescription,
+	int endpointJitter,
+	int endpointRtpOctetsDiscarded,
+	int endpointRtpOctetsReceived,
+	int endpointRtpOctetsSent,
+	int endpointRtpPacketsDiscarded,
+	int endpointRtpPacketsReceived,
+	int endpointRtpPacketsSent,
+	int localJitter,
+	int localRtpOctetsDiscarded,
+	int localRtpOctetsReceived,
+	int localRtpOctetsSent,
+	int localRtpPacketsDiscarded,
+	int localRtpPacketsReceived,
+	int localRtpPacketsSent,
+	int mosCqe,
+	int packetsLost,
+	int packetLossPercent,
+	int rFactor,
+	int roundTripDelay);
+
+/**************************************************************************//**
+ * Free a Voice Quality.
+ *
+ * Free off the Voce Quality supplied.  Will free all the contained allocated
+ * memory.
+ *
+ * @note It does not free the Voice Quality itself, since that may be part of a
+ * larger structure.
+ *****************************************************************************/
+void evel_free_voice_quality(EVENT_VOICE_QUALITY * voiceQuality);
+
+/**************************************************************************//**
+ * Add an additional value name/value pair to the Voice Quality.
+ *
+ * The name and value are null delimited ASCII strings.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param fault     Pointer to the fault.
+ * @param name      ASCIIZ string with the attribute's name.  The caller
+ *                  does not need to preserve the value once the function
+ *                  returns.
+ * @param value     ASCIIZ string with the attribute's value.  The caller
+ *                  does not need to preserve the value once the function
+ *                  returns.
+ *****************************************************************************/
+void evel_voice_quality_addl_info_add(EVENT_VOICE_QUALITY * voiceQuality, char * name, char * value);
+
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   THRESHOLD CROSSING ALERT                                                */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+typedef enum evel_event_action {
+	  EVEL_EVENT_ACTION_CLEAR,
+	  EVEL_EVENT_ACTION_CONTINUE,
+	  EVEL_EVENT_ACTION_SET,
+	  EVEL_MAX_EVENT_ACTION
+}EVEL_EVENT_ACTION;
+	
+typedef enum evel_alert_type {
+         EVEL_CARD_ANOMALY, 
+   	 EVEL_ELEMENT_ANOMALY, 
+    	 EVEL_INTERFACE_ANOMALY, 
+    	 EVEL_SERVICE_ANOMALY,
+         EVEL_MAX_ANOMALY
+}EVEL_ALERT_TYPE;
+
+
+typedef struct perf_counter {
+	char * criticality;
+	char * name;
+	char * thresholdCrossed;
+	char * value;
+}PERF_COUNTER;
+
+
+/*****************************************************************************/
+/* Supported Threshold Crossing version.                                     */
+/*****************************************************************************/
+#define EVEL_THRESHOLD_CROSS_MAJOR_VERSION 1
+#define EVEL_THRESHOLD_CROSS_MINOR_VERSION 1
+
+/**************************************************************************//**
+ * Threshold Crossing.
+ * JSON equivalent field: Threshold Cross Fields
+ *****************************************************************************/
+typedef struct event_threshold_cross {
+  /***************************************************************************/
+  /* Header and version                                                      */
+  /***************************************************************************/
+  EVENT_HEADER header;
+  int major_version;
+  int minor_version;
+
+  /***************************************************************************/
+  /* Mandatory fields                                                        */
+  /***************************************************************************/
+  PERF_COUNTER additionalParameters;
+  EVEL_EVENT_ACTION  alertAction;
+  char *             alertDescription; 
+  EVEL_ALERT_TYPE    alertType;
+  unsigned long long collectionTimestamp; 
+  EVEL_SEVERITIES    eventSeverity;
+  unsigned long long eventStartTimestamp;
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /***************************************************************************/
+  DLIST additional_info;
+  EVEL_OPTION_STRING    alertValue;
+  DLIST     alertidList;
+  EVEL_OPTION_STRING    dataCollector;
+  EVEL_OPTION_STRING    elementType;
+  EVEL_OPTION_STRING    interfaceName;
+  EVEL_OPTION_STRING    networkService;
+  EVEL_OPTION_STRING    possibleRootCause;
+
+} EVENT_THRESHOLD_CROSS;
+
+
+/**************************************************************************//**
+ * Create a new Threshold Crossing Alert event.
+ *
+ * @note    The mandatory fields on the TCA must be supplied to this factory
+ *          function and are immutable once set.  Optional fields have explicit
+ *          setter functions, but again values may only be set once so that the
+ *          TCA has immutable properties.
+ *
+ * @param event_name    Unique Event Name
+ * @param event_id    A universal identifier of the event for analysis etc
+ * @param char* tcriticality   Performance Counter Criticality MAJ MIN,
+ * @param char* tname          Performance Counter Threshold name
+ * @param char* tthresholdCrossed  Counter Threshold crossed value
+ * @param char* tvalue             Counter actual value
+ * @param EVEL_EVENT_ACTION talertAction   Alert set continue or clear
+ * @param char*  talertDescription
+ * @param EVEL_ALERT_TYPE     talertType    Kind of anamoly
+ * @param unsigned long long  tcollectionTimestamp time at which alert was collected
+ * @param EVEL_SEVERITIES     teventSeverity  Severity of Alert
+ * @param unsigned long long  teventStartTimestamp Time when this alert started
+ *
+ * @returns pointer to the newly manufactured ::EVENT_THRESHOLD_CROSS.  If the
+ *          event is not used it must be released using
+ *          ::evel_free_threshold_cross
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_THRESHOLD_CROSS * evel_new_threshold_cross(
+				const char* ev_name, const char *ev_id,
+                               char * tcriticality,
+	                       char * tname,
+	                       char * tthresholdCrossed,
+	                       char * tvalue,
+                               EVEL_EVENT_ACTION  talertAction,
+                               char *             talertDescription, 
+                               EVEL_ALERT_TYPE    talertType,
+                               unsigned long long tcollectionTimestamp, 
+                               EVEL_SEVERITIES    teventSeverity,
+                               unsigned long long teventStartTimestamp);
+
+/**************************************************************************//**
+ * Free a Threshold cross event.
+ *
+ * Free off the Threshold crossing event supplied.  Will free all the contained allocated
+ * memory.
+ *
+ * @note It does not free the Threshold Cross itself, since that may be part of a
+ * larger structure.
+ *****************************************************************************/
+void evel_free_threshold_cross(EVENT_THRESHOLD_CROSS * const tcp);
+
+/**************************************************************************//**
+ * Set the Event Type property of the Threshold Cross.
+ *
+ * @note  The property is treated as immutable: it is only valid to call
+ *        the setter once.  However, we don't assert if the caller tries to
+ *        overwrite, just ignoring the update instead.
+ *
+ * @param tcp  Pointer to the ::EVENT_THRESHOLD_CROSS.
+ * @param type          The Event Type to be set. ASCIIZ string. The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_threshold_cross_type_set(EVENT_THRESHOLD_CROSS * const tcp, char * type);
+
+/**************************************************************************//**
+ * Add an optional additional alertid value to Alert.
+ *
+ * @param alertid  Adds Alert ID
+ *****************************************************************************/
+void evel_threshold_cross_alertid_add(EVENT_THRESHOLD_CROSS * const event,char *  alertid);
+
+  /**************************************************************************//**
+   * Set the TCA probable Root cause.
+   *
+   * @param sheader     Possible root cause to Threshold
+   *****************************************************************************/
+  void evel_threshold_cross_possible_rootcause_set(EVENT_THRESHOLD_CROSS * const event, char *  sheader);
+  /**************************************************************************//**
+   * Set the TCA networking cause.
+   *
+   * @param sheader     Possible networking service value to Threshold
+   *****************************************************************************/
+  void evel_threshold_cross_networkservice_set(EVENT_THRESHOLD_CROSS * const event, char *  sheader);
+  /**************************************************************************//**
+   * Set the TCA Interface name.
+   *
+   * @param sheader     Interface name to threshold
+   *****************************************************************************/
+  void evel_threshold_cross_interfacename_set(EVENT_THRESHOLD_CROSS * const event,char *  sheader);
+  /**************************************************************************//**
+   * Set the TCA Data element type.
+   *
+   * @param sheader     element type of Threshold
+   *****************************************************************************/
+  void evel_threshold_cross_data_elementtype_set(EVENT_THRESHOLD_CROSS * const event,char *  sheader);
+  /**************************************************************************//**
+   * Set the TCA Data collector value.
+   *
+   * @param sheader     Data collector value
+   *****************************************************************************/
+  void evel_threshold_cross_data_collector_set(EVENT_THRESHOLD_CROSS * const event,char *  sheader);
+  /**************************************************************************//**
+   * Set the TCA alert value.
+   *
+   * @param sheader     Possible alert value
+   *****************************************************************************/
+  void evel_threshold_cross_alertvalue_set(EVENT_THRESHOLD_CROSS * const event,char *  sheader);
+
+/**************************************************************************//**
+ * Add an additional field name/value pair to the THRESHOLD CROSS event.
+ *
+ * The name and value are null delimited ASCII strings.  The library takes
+ * a copy so the caller does not have to preserve values after the function
+ * returns.
+ *
+ * @param state_change  Pointer to the ::EVENT_THRESHOLD_CROSS.
+ * @param name          ASCIIZ string with the attribute's name.  The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ * @param value         ASCIIZ string with the attribute's value.  The caller
+ *                      does not need to preserve the value once the function
+ *                      returns.
+ *****************************************************************************/
+void evel_threshold_cross_addl_info_add(EVENT_THRESHOLD_CROSS * const tcp,
+                                      const char * const name,
+                                      const char * const value);
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                                                                           */
+/*   LOGGING                                                                 */
+/*                                                                           */
+/*****************************************************************************/
+/*****************************************************************************/
+
+/*****************************************************************************/
+/* Debug macros.                                                             */
+/*****************************************************************************/
+#define EVEL_DEBUG(FMT, ...)   log_debug(EVEL_LOG_DEBUG, (FMT), ##__VA_ARGS__)
+#define EVEL_INFO(FMT, ...)    log_debug(EVEL_LOG_INFO, (FMT), ##__VA_ARGS__)
+#define EVEL_SPAMMY(FMT, ...)  log_debug(EVEL_LOG_SPAMMY, (FMT), ##__VA_ARGS__)
+#define EVEL_ERROR(FMT, ...)   log_debug(EVEL_LOG_ERROR, "ERROR: " FMT, \
+                                         ##__VA_ARGS__)
+#define EVEL_ENTER()                                                          \
+        {                                                                     \
+          log_debug(EVEL_LOG_DEBUG, "Enter %s {", __FUNCTION__);              \
+          debug_indent += 2;                                                  \
+        }
+#define EVEL_EXIT()                                                           \
+        {                                                                     \
+          debug_indent -= 2;                                                  \
+          log_debug(EVEL_LOG_DEBUG, "Exit %s }", __FUNCTION__);               \
+        }
+
+#define INDENT_SEPARATORS                                                     \
+        "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | "
+
+extern EVEL_LOG_LEVELS debug_level;
+extern int debug_indent;
+extern FILE * fout;
+
+#define EVEL_DEBUG_ON() ((debug_level) >= EVEL_LOG_DEBUG)
+
+/**************************************************************************//**
+ * Initialize logging
+ *
+ * @param[in] level  The debugging level - one of ::EVEL_LOG_LEVELS.
+ * @param[in] ident  The identifier for our logs.
+ *****************************************************************************/
+void log_initialize(EVEL_LOG_LEVELS level, const char * ident);
+
+/**************************************************************************//**
+ * Log debug information
+ *
+ * Logs debugging information in a platform independent manner.
+ *
+ * @param[in] level   The debugging level - one of ::EVEL_LOG_LEVELS.
+ * @param[in] format  Log formatting string in printf format.
+ * @param[in] ...     Variable argument list.
+ *****************************************************************************/
+void log_debug(EVEL_LOG_LEVELS level, char * format, ...);
+
+/***************************************************************************//*
+ * Store the formatted string into the static error string and log the error.
+ *
+ * @param format  Error string in standard printf format.
+ * @param ...     Variable parameters to be substituted into the format string.
+ *****************************************************************************/
+void log_error_state(char * format, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/src/plugins/ves/include/evel_internal.h b/src/plugins/ves/include/evel_internal.h
new file mode 100644
index 00000000..46f71af1
--- /dev/null
+++ b/src/plugins/ves/include/evel_internal.h
@@ -0,0 +1,858 @@
+/*************************************************************************//**
+ *
+ * Copyright © 2017 AT&T Intellectual Property. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ *
+ ****************************************************************************/
+/**************************************************************************//**
+ * @file
+ * EVEL internal definitions.
+ *
+ * These are internal definitions which need to be shared between modules
+ * within the library but are not intended for external consumption.
+ *
+ ****************************************************************************/
+
+#ifndef EVEL_INTERNAL_INCLUDED
+#define EVEL_INTERNAL_INCLUDED
+
+#include "evel.h"
+
+/*****************************************************************************/
+/* Define some type-safe min/max macros.                                     */
+/*****************************************************************************/
+#define max(a,b) \
+   ({ __typeof__ (a) _a = (a); \
+       __typeof__ (b) _b = (b); \
+     _a > _b ? _a : _b; })
+
+#define min(a,b) \
+   ({ __typeof__ (a) _a = (a); \
+       __typeof__ (b) _b = (b); \
+     _a < _b ? _a : _b; })
+
+
+/**************************************************************************//**
+ * Compile-time assertion.
+ *****************************************************************************/
+#define EVEL_CT_ASSERT(X) switch (0) {case 0: case (X):;}
+
+/**************************************************************************//**
+ * The Functional Role of the equipment represented by this VNF.
+ *****************************************************************************/
+extern char * functional_role;
+
+/**************************************************************************//**
+ * The type of equipment represented by this VNF.
+ *****************************************************************************/
+extern EVEL_SOURCE_TYPES event_source_type;
+
+/**************************************************************************//**
+ * A chunk of memory used in the cURL functions.
+ *****************************************************************************/
+typedef struct memory_chunk {
+  char * memory;
+  size_t size;
+} MEMORY_CHUNK;
+
+/**************************************************************************//**
+ * Global commands that may be sent to the Event Handler thread.
+ *****************************************************************************/
+typedef enum {
+  EVT_CMD_TERMINATE,
+  EVT_CMD_MAX_COMMANDS
+} EVT_HANDLER_COMMAND;
+
+/**************************************************************************//**
+ * State of the Event Handler thread.
+ *****************************************************************************/
+typedef enum {
+  EVT_HANDLER_UNINITIALIZED,      /** The library cannot handle events.      */
+  EVT_HANDLER_INACTIVE,           /** The event handler thread not started.  */
+  EVT_HANDLER_ACTIVE,             /** The event handler thread is started.   */
+  EVT_HANDLER_REQUEST_TERMINATE,  /** Initial stages of shutdown.            */
+  EVT_HANDLER_TERMINATING,        /** The ring-buffer is being depleted.     */
+  EVT_HANDLER_TERMINATED,         /** The library is exited.                 */
+  EVT_HANDLER_MAX_STATES          /** Maximum number of valid states.        */
+} EVT_HANDLER_STATE;
+
+/**************************************************************************//**
+ * Internal event.
+ * Pseudo-event used for routing internal commands.
+ *****************************************************************************/
+typedef struct event_internal {
+  EVENT_HEADER header;
+  EVT_HANDLER_COMMAND command;
+} EVENT_INTERNAL;
+
+/**************************************************************************//**
+ * Suppressed NV pairs list entry.
+ * JSON equivalent field: suppressedNvPairs
+ *****************************************************************************/
+typedef struct evel_suppressed_nv_pairs {
+
+  /***************************************************************************/
+  /* Mandatory fields                                                        */
+  /* JSON equivalent field: nvPairFieldName                                  */
+  /***************************************************************************/
+  char * nv_pair_field_name;
+
+  /***************************************************************************/
+  /* Optional fields                                                         */
+  /* JSON equivalent field: suppressedNvPairNames                            */
+  /* Type of each list entry: char *                                         */
+  /***************************************************************************/
+  DLIST suppressed_nv_pair_names;
+
+  /***************************************************************************/
+  /* Hash table containing suppressed_nv_pair_names as keys.                 */
+  /***************************************************************************/
+  struct hsearch_data * hash_nv_pair_names;
+
+} EVEL_SUPPRESSED_NV_PAIRS;
+
+/**************************************************************************//**
+ * Event Throttling Specification for a domain which is in a throttled state.
+ * JSON equivalent object: eventThrottlingState
+ *****************************************************************************/
+typedef struct evel_throttle_spec {
+
+  /***************************************************************************/
+  /* List of field names to be suppressed.                                   */
+  /* JSON equivalent field: suppressedFieldNames                             */
+  /* Type of each list entry: char *                                         */
+  /***************************************************************************/
+  DLIST suppressed_field_names;
+
+  /***************************************************************************/
+  /* List of name-value pairs to be suppressed.                              */
+  /* JSON equivalent field: suppressedNvPairsList                            */
+  /* Type of each list entry: EVEL_SUPPRESSED_NV_PAIRS *                     */
+  /***************************************************************************/
+  DLIST suppressed_nv_pairs_list;
+
+  /***************************************************************************/
+  /* Hash table containing suppressed_nv_pair_names as keys.                 */
+  /***************************************************************************/
+  struct hsearch_data * hash_field_names;
+
+  /***************************************************************************/
+  /* Hash table containing nv_pair_field_name as keys, and                   */
+  /* suppressed_nv_pairs_list as values.                                     */
+  /***************************************************************************/
+  struct hsearch_data * hash_nv_pairs_list;
+
+} EVEL_THROTTLE_SPEC;
+
+/*****************************************************************************/
+/* RFC2822 format string for strftime.                                       */
+/*****************************************************************************/
+#define EVEL_RFC2822_STRFTIME_FORMAT "%a, %d %b %Y %T %z"
+
+/*****************************************************************************/
+/* EVEL_JSON_BUFFER depth at which we throttle fields.                       */
+/*****************************************************************************/
+#define EVEL_THROTTLE_FIELD_DEPTH 3
+
+/**************************************************************************//**
+ * Initialize the event handler.
+ *
+ * Primarily responsible for getting cURL ready for use.
+ *
+ * @param[in] event_api_url
+ *                      The URL where the Vendor Event Listener API is expected
+ *                      to be.
+ * @param[in] throt_api_url
+ *                      The URL where the Throttling API is expected to be.
+ * @param[in] username  The username for the Basic Authentication of requests.
+ * @param[in] password  The password for the Basic Authentication of requests.
+ * @param     verbosity 0 for normal operation, positive values for chattier
+ *                        logs.
+ *****************************************************************************/
+EVEL_ERR_CODES event_handler_initialize(const char * const event_api_url,
+                                        const char * const throt_api_url,
+                                        const char * const username,
+                                        const char * const password,
+                                        int verbosity);
+
+/**************************************************************************//**
+ * Terminate the event handler.
+ *
+ * Shuts down the event handler thread in as clean a way as possible. Sets the
+ * global exit flag and then signals the thread to interrupt it since it's
+ * most likely waiting on the ring-buffer.
+ *
+ * Having achieved an orderly shutdown of the event handler thread, clean up
+ * the cURL library's resources cleanly.
+ *
+ *  @return Status code.
+ *  @retval ::EVEL_SUCCESS if everything OK.
+ *  @retval One of ::EVEL_ERR_CODES if there was a problem.
+ *****************************************************************************/
+EVEL_ERR_CODES event_handler_terminate();
+
+/**************************************************************************//**
+ * Run the event handler.
+ *
+ * Spawns the thread responsible for handling events and sending them to the
+ * API.
+ *
+ *  @return Status code.
+ *  @retval ::EVEL_SUCCESS if everything OK.
+ *  @retval One of ::EVEL_ERR_CODES if there was a problem.
+ *****************************************************************************/
+EVEL_ERR_CODES event_handler_run();
+
+/**************************************************************************//**
+ * Create a new internal event.
+ *
+ * @note    The mandatory fields on the Fault must be supplied to this factory
+ *          function and are immutable once set.  Optional fields have explicit
+ *          setter functions, but again values may only be set once so that the
+ *          Fault has immutable properties.
+ * @param   command   The condition indicated by the event.
+ * @returns pointer to the newly manufactured ::EVENT_INTERNAL.  If the event
+ *          is not used (i.e. posted) it must be released using
+ *          ::evel_free_event.
+ * @retval  NULL  Failed to create the event.
+ *****************************************************************************/
+EVENT_INTERNAL * evel_new_internal_event(EVT_HANDLER_COMMAND command,const char* ev_name, const char *ev_id);
+
+/**************************************************************************//**
+ * Free an internal event.
+ *
+ * Free off the event supplied.  Will free all the contained* allocated memory.
+ *
+ * @note It does not free the internal event itself, since that may be part of
+ * a larger structure.
+ *****************************************************************************/
+void evel_free_internal_event(EVENT_INTERNAL * event);
+
+/*****************************************************************************/
+/* Structure to hold JSON buffer and associated tracking, as it is written.  */
+/*****************************************************************************/
+typedef struct evel_json_buffer
+{
+  char * json;
+  int offset;
+  int max_size;
+
+  /***************************************************************************/
+  /* The working throttle specification, which can be NULL.                  */
+  /***************************************************************************/
+  EVEL_THROTTLE_SPEC * throttle_spec;
+
+  /***************************************************************************/
+  /* Current object/list nesting depth.                                      */
+  /***************************************************************************/
+  int depth;
+
+  /***************************************************************************/
+  /* The checkpoint.                                                         */
+  /***************************************************************************/
+  int checkpoint;
+
+} EVEL_JSON_BUFFER;
+
+/**************************************************************************//**
+ * Encode the event as a JSON event object according to AT&T's schema.
+ *
+ * @param jbuf          Pointer to the ::EVEL_JSON_BUFFER to encode into.
+ * @param event         Pointer to the ::EVENT_HEADER to encode.
+ *****************************************************************************/
+void evel_json_encode_header(EVEL_JSON_BUFFER * jbuf,
+                             EVENT_HEADER * event);
+
+/**************************************************************************//**
+ * Encode the fault in JSON according to AT&T's schema for the fault type.
+ *
+ * @param jbuf          Pointer to the ::EVEL_JSON_BUFFER to encode into.
+ * @param event         Pointer to the ::EVENT_HEADER to encode.
+ *****************************************************************************/
+void evel_json_encode_fault(EVEL_JSON_BUFFER * jbuf,
+                            EVENT_FAULT * event);
+
+/**************************************************************************//**
+ * Encode the measurement as a JSON measurement.
+ *
+ * @param jbuf          Pointer to the ::EVEL_JSON_BUFFER to encode into.
+ * @param event         Pointer to the ::EVENT_HEADER to encode.
+ *****************************************************************************/
+void evel_json_encode_measurement(EVEL_JSON_BUFFER * jbuf,
+                                  EVENT_MEASUREMENT * event);
+
+/**************************************************************************//**
+ * Encode the Mobile Flow in JSON according to AT&T's schema for the event
+ * type.
+ *
+ * @param jbuf          Pointer to the ::EVEL_JSON_BUFFER to encode into.
+ * @param event         Pointer to the ::EVENT_HEADER to encode.
+ *****************************************************************************/
+void evel_json_encode_mobile_flow(EVEL_JSON_BUFFER * jbuf,
+                                  EVENT_MOBILE_FLOW * event);
+
+/**************************************************************************//**
+ * Encode the report as a JSON report.
+ *
+ * @param jbuf          Pointer to the ::EVEL_JSON_BUFFER to encode into.
+ * @param event         Pointer to the ::EVENT_HEADER to encode.
+ *****************************************************************************/
+void evel_json_encode_report(EVEL_JSON_BUFFER * jbuf,
+                             EVENT_REPORT * event);
+
+/**************************************************************************//**
+ * Encode the Heartbeat fields in JSON according to AT&T's schema for the
+ * event type.
+ *
+ * @param jbuf          Pointer to the ::EVEL_JSON_BUFFER to encode into.
+ * @param event         Pointer to the ::EVENT_HEADER to encode.
+ *****************************************************************************/
+void evel_json_encode_hrtbt_field(EVEL_JSON_BUFFER * const jbuf,
+                                EVENT_HEARTBEAT_FIELD * const event);
+
+/**************************************************************************//**
+ * Encode the Signaling in JSON according to AT&T's schema for the event type.
+ *
+ * @param jbuf          Pointer to the ::EVEL_JSON_BUFFER to encode into.
+ * @param event         Pointer to the ::EVENT_HEADER to encode.
+ *****************************************************************************/
+void evel_json_encode_signaling(EVEL_JSON_BUFFER * const jbuf,
+                                EVENT_SIGNALING * const event);
+
+/**************************************************************************//**
+ * Encode the state change as a JSON state change.
+ *
+ * @param jbuf          Pointer to the ::EVEL_JSON_BUFFER to encode into.
+ * @param state_change  Pointer to the ::EVENT_STATE_CHANGE to encode.
+ *****************************************************************************/
+void evel_json_encode_state_change(EVEL_JSON_BUFFER * jbuf,
+                                   EVENT_STATE_CHANGE * state_change);
+
+/**************************************************************************//**
+ * Encode the Syslog in JSON according to AT&T's schema for the event type.
+ *
+ * @param jbuf          Pointer to the ::EVEL_JSON_BUFFER to encode into.
+ * @param event         Pointer to the ::EVENT_HEADER to encode.
+ *****************************************************************************/
+void evel_json_encode_syslog(EVEL_JSON_BUFFER * jbuf,
+                             EVENT_SYSLOG * event);
+
+/**************************************************************************//**
+ * Encode the Other in JSON according to AT&T's schema for the event type.
+ *
+ * @param jbuf          Pointer to the ::EVEL_JSON_BUFFER to encode into.
+ * @param event         Pointer to the ::EVENT_HEADER to encode.
+ *****************************************************************************/
+void evel_json_encode_other(EVEL_JSON_BUFFER * jbuf,
+                            EVENT_OTHER * event);
+
+/**************************************************************************//**
+ * Set the next event_sequence to use.
+ *
+ * @param sequence      The next sequence number to use.
+ *****************************************************************************/
+void evel_set_next_event_sequence(const int sequence);
+
+/**************************************************************************//**
+ * Handle a JSON response from the listener, contained in a ::MEMORY_CHUNK.
+ *
+ * Tokenize the response, and decode any tokens found.
+ *
+ * @param chunk         The memory chunk containing the response.
+ * @param post          The memory chunk in which to place any resulting POST.
+ *****************************************************************************/
+void evel_handle_event_response(const MEMORY_CHUNK * const chunk,
+                                MEMORY_CHUNK * const post);
+
+/**************************************************************************//**
+ * Initialize a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to the ::EVEL_JSON_BUFFER to initialise.
+ * @param json          Pointer to the underlying working buffer to use.
+ * @param max_size      Size of storage available in the JSON buffer.
+ * @param throttle_spec Pointer to throttle specification. Can be NULL.
+ *****************************************************************************/
+void evel_json_buffer_init(EVEL_JSON_BUFFER * jbuf,
+                           char * const json,
+                           const int max_size,
+                           EVEL_THROTTLE_SPEC * throttle_spec);
+
+/**************************************************************************//**
+ * Encode a string key and string value to a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @param option        Pointer to holder of the corresponding value to encode.
+ * @return true if the key, value was added, false if it was suppressed.
+ *****************************************************************************/
+bool evel_enc_kv_opt_string(EVEL_JSON_BUFFER * jbuf,
+                            const char * const key,
+                            const EVEL_OPTION_STRING * const option);
+
+/**************************************************************************//**
+ * Encode a string key and string value to a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @param value         Pointer to the corresponding value to encode.
+ *****************************************************************************/
+void evel_enc_kv_string(EVEL_JSON_BUFFER * jbuf,
+                        const char * const key,
+                        const char * const value);
+
+/**************************************************************************//**
+ * Encode a string key and integer value to a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @param option        Pointer to holder of the corresponding value to encode.
+ * @return true if the key, value was added, false if it was suppressed.
+ *****************************************************************************/
+bool evel_enc_kv_opt_int(EVEL_JSON_BUFFER * jbuf,
+                         const char * const key,
+                         const EVEL_OPTION_INT * const option);
+
+/**************************************************************************//**
+ * Encode a string key and integer value to a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @param value         The corresponding value to encode.
+ *****************************************************************************/
+void evel_enc_kv_int(EVEL_JSON_BUFFER * jbuf,
+                     const char * const key,
+                     const int value);
+
+/**************************************************************************//**
+ * Encode a string key and double value to a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @param option        Pointer to holder of the corresponding value to encode.
+ * @return true if the key, value was added, false if it was suppressed.
+ *****************************************************************************/
+bool evel_enc_kv_opt_double(EVEL_JSON_BUFFER * jbuf,
+                            const char * const key,
+                            const EVEL_OPTION_DOUBLE * const option);
+
+/**************************************************************************//**
+ * Encode a string key and double value to a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @param value         The corresponding value to encode.
+ *****************************************************************************/
+void evel_enc_kv_double(EVEL_JSON_BUFFER * jbuf,
+                        const char * const key,
+                        const double value);
+
+/**************************************************************************//**
+ * Encode a string key and unsigned long long value to a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @param option        Pointer to holder of the corresponding value to encode.
+ * @return true if the key, value was added, false if it was suppressed.
+ *****************************************************************************/
+bool evel_enc_kv_opt_ull(EVEL_JSON_BUFFER * jbuf,
+                         const char * const key,
+                         const EVEL_OPTION_ULL * const option);
+
+/**************************************************************************//**
+ * Encode a string key and unsigned long long value to a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @param value         The corresponding value to encode.
+ *****************************************************************************/
+void evel_enc_kv_ull(EVEL_JSON_BUFFER * jbuf,
+                     const char * const key,
+                     const unsigned long long value);
+
+/**************************************************************************//**
+ * Encode a string key and time value to a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @param option        Pointer to holder of the corresponding value to encode.
+ * @return true if the key, value was added, false if it was suppressed.
+ *****************************************************************************/
+bool evel_enc_kv_opt_time(EVEL_JSON_BUFFER * jbuf,
+                          const char * const key,
+                          const EVEL_OPTION_TIME * const option);
+
+/**************************************************************************//**
+ * Encode a string key and time value to a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @param time          Pointer to the time to encode.
+ *****************************************************************************/
+void evel_enc_kv_time(EVEL_JSON_BUFFER * jbuf,
+                      const char * const key,
+                      const time_t * time);
+
+/**************************************************************************//**
+ * Encode a key and version.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @param major_version The major version to encode.
+ * @param minor_version The minor version to encode.
+ *****************************************************************************/
+void evel_enc_version(EVEL_JSON_BUFFER * jbuf,
+                      const char * const key,
+                      const int major_version,
+                      const int minor_version);
+
+/**************************************************************************//**
+ * Add the key and opening bracket of an optional named list to a JSON buffer.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @return true if the list was opened, false if it was suppressed.
+ *****************************************************************************/
+bool evel_json_open_opt_named_list(EVEL_JSON_BUFFER * jbuf,
+                                   const char * const key);
+
+/**************************************************************************//**
+ * Add the key and opening bracket of a named list to a JSON buffer.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ *****************************************************************************/
+void evel_json_open_named_list(EVEL_JSON_BUFFER * jbuf,
+                               const char * const key);
+
+/**************************************************************************//**
+ * Add the closing bracket of a list to a JSON buffer.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ *****************************************************************************/
+void evel_json_close_list(EVEL_JSON_BUFFER * jbuf);
+
+/**************************************************************************//**
+ * Encode a list item with format and param list to a ::EVEL_JSON_BUFFER.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param format        Format string in standard printf format.
+ * @param ...           Variable parameters for format string.
+ *****************************************************************************/
+void evel_enc_list_item(EVEL_JSON_BUFFER * jbuf,
+                        const char * const format,
+                        ...);
+
+/**************************************************************************//**
+ * Add the opening bracket of an optional named object to a JSON buffer.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ *****************************************************************************/
+bool evel_json_open_opt_named_object(EVEL_JSON_BUFFER * jbuf,
+                                     const char * const key);
+
+/**************************************************************************//**
+ * Add the opening bracket of an object to a JSON buffer.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ * @param key           Pointer to the key to encode.
+ * @return true if the object was opened, false if it was suppressed.
+ *****************************************************************************/
+void evel_json_open_named_object(EVEL_JSON_BUFFER * jbuf,
+                                 const char * const key);
+
+/**************************************************************************//**
+ * Add the opening bracket of an object to a JSON buffer.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ *****************************************************************************/
+void evel_json_open_object(EVEL_JSON_BUFFER * jbuf);
+
+/**************************************************************************//**
+ * Add the closing bracket of an object to a JSON buffer.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ *****************************************************************************/
+void evel_json_close_object(EVEL_JSON_BUFFER * jbuf);
+
+/**************************************************************************//**
+ * Add a checkpoint - a stake in the ground to which we can rewind.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ *****************************************************************************/
+void evel_json_checkpoint(EVEL_JSON_BUFFER * jbuf);
+
+/**************************************************************************//**
+ * Rewind to the latest checkoint.
+ *
+ * @param jbuf          Pointer to working ::EVEL_JSON_BUFFER.
+ *****************************************************************************/
+void evel_json_rewind(EVEL_JSON_BUFFER * jbuf);
+
+/**************************************************************************//**
+ * Free the underlying resources of an ::EVEL_OPTION_STRING.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_STRING.
+ *****************************************************************************/
+void evel_free_option_string(EVEL_OPTION_STRING * const option);
+
+/**************************************************************************//**
+ * Initialize an ::EVEL_OPTION_STRING to a not-set state.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_STRING.
+ *****************************************************************************/
+void evel_init_option_string(EVEL_OPTION_STRING * const option);
+
+/**************************************************************************//**
+ * Set the value of an ::EVEL_OPTION_STRING.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_STRING.
+ * @param value         The value to set.
+ * @param description   Description to be used in logging.
+ *****************************************************************************/
+void evel_set_option_string(EVEL_OPTION_STRING * const option,
+                            const char * const value,
+                            const char * const description);
+
+/**************************************************************************//**
+ * Force the value of an ::EVEL_OPTION_STRING.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_STRING.
+ * @param value         The value to set.
+ *****************************************************************************/
+void evel_force_option_string(EVEL_OPTION_STRING * const option,
+                              const char * const value);
+
+/**************************************************************************//**
+ * Initialize an ::EVEL_OPTION_INT to a not-set state.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_INT.
+ *****************************************************************************/
+void evel_init_option_int(EVEL_OPTION_INT * const option);
+
+/**************************************************************************//**
+ * Force the value of an ::EVEL_OPTION_INT.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_INT.
+ * @param value         The value to set.
+ *****************************************************************************/
+void evel_force_option_int(EVEL_OPTION_INT * const option,
+                           const int value);
+
+/**************************************************************************//**
+ * Set the value of an ::EVEL_OPTION_INT.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_INT.
+ * @param value         The value to set.
+ * @param description   Description to be used in logging.
+ *****************************************************************************/
+void evel_set_option_int(EVEL_OPTION_INT * const option,
+                         const int value,
+                         const char * const description);
+
+/**************************************************************************//**
+ * Initialize an ::EVEL_OPTION_DOUBLE to a not-set state.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_DOUBLE.
+ *****************************************************************************/
+void evel_init_option_double(EVEL_OPTION_DOUBLE * const option);
+
+/**************************************************************************//**
+ * Force the value of an ::EVEL_OPTION_DOUBLE.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_DOUBLE.
+ * @param value         The value to set.
+ *****************************************************************************/
+void evel_force_option_double(EVEL_OPTION_DOUBLE * const option,
+                              const double value);
+
+/**************************************************************************//**
+ * Set the value of an ::EVEL_OPTION_DOUBLE.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_DOUBLE.
+ * @param value         The value to set.
+ * @param description   Description to be used in logging.
+ *****************************************************************************/
+void evel_set_option_double(EVEL_OPTION_DOUBLE * const option,
+                            const double value,
+                            const char * const description);
+
+/**************************************************************************//**
+ * Initialize an ::EVEL_OPTION_ULL to a not-set state.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_ULL.
+ *****************************************************************************/
+void evel_init_option_ull(EVEL_OPTION_ULL * const option);
+
+/**************************************************************************//**
+ * Force the value of an ::EVEL_OPTION_ULL.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_ULL.
+ * @param value         The value to set.
+ *****************************************************************************/
+void evel_force_option_ull(EVEL_OPTION_ULL * const option,
+                           const unsigned long long value);
+
+/**************************************************************************//**
+ * Set the value of an ::EVEL_OPTION_ULL.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_ULL.
+ * @param value         The value to set.
+ * @param description   Description to be used in logging.
+ *****************************************************************************/
+void evel_set_option_ull(EVEL_OPTION_ULL * const option,
+                         const unsigned long long value,
+                         const char * const description);
+
+/**************************************************************************//**
+ * Initialize an ::EVEL_OPTION_TIME to a not-set state.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_TIME.
+ *****************************************************************************/
+void evel_init_option_time(EVEL_OPTION_TIME * const option);
+
+/**************************************************************************//**
+ * Force the value of an ::EVEL_OPTION_TIME.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_TIME.
+ * @param value         The value to set.
+ *****************************************************************************/
+void evel_force_option_time(EVEL_OPTION_TIME * const option,
+                            const time_t value);
+
+/**************************************************************************//**
+ * Set the value of an ::EVEL_OPTION_TIME.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_TIME.
+ * @param value         The value to set.
+ * @param description   Description to be used in logging.
+ *****************************************************************************/
+void evel_set_option_time(EVEL_OPTION_TIME * const option,
+                          const time_t value,
+                          const char * const description);
+
+/**************************************************************************//**
+ * Map an ::EVEL_COUNTER_CRITICALITIES enum value to the equivalent string.
+ *
+ * @param criticality   The criticality to convert.
+ * @returns The equivalent string.
+ *****************************************************************************/
+char * evel_criticality(const EVEL_COUNTER_CRITICALITIES criticality);
+
+/**************************************************************************//**
+ * Map an ::EVEL_SEVERITIES enum value to the equivalent string.
+ *
+ * @param severity      The severity to convert.
+ * @returns The equivalent string.
+ *****************************************************************************/
+char * evel_severity(const EVEL_SEVERITIES severity);
+
+/**************************************************************************//**
+ * Map an ::EVEL_ALERT_ACTIONS enum value to the equivalent string.
+ *
+ * @param alert_action  The alert_action to convert.
+ * @returns The equivalent string.
+ *****************************************************************************/
+char * evel_alert_action(const EVEL_ALERT_ACTIONS alert_action);
+
+/**************************************************************************//**
+ * Map an ::EVEL_ALERT_TYPES enum value to the equivalent string.
+ *
+ * @param alert_type    The alert_type to convert.
+ * @returns The equivalent string.
+ *****************************************************************************/
+char * evel_alert_type(const EVEL_ALERT_TYPES alert_type);
+
+/**************************************************************************//**
+ * Map an ::EVEL_EVENT_DOMAINS enum value to the equivalent string.
+ *
+ * @param domain        The domain to convert.
+ * @returns The equivalent string.
+ *****************************************************************************/
+char * evel_event_domain(const EVEL_EVENT_DOMAINS domain);
+
+/**************************************************************************//**
+ * Map an ::EVEL_EVENT_PRIORITIES enum value to the equivalent string.
+ *
+ * @param priority      The priority to convert.
+ * @returns The equivalent string.
+ *****************************************************************************/
+char * evel_event_priority(const EVEL_EVENT_PRIORITIES priority);
+
+/**************************************************************************//**
+ * Map an ::EVEL_SOURCE_TYPES enum value to the equivalent string.
+ *
+ * @param source_type   The source type to convert.
+ * @returns The equivalent string.
+ *****************************************************************************/
+char * evel_source_type(const EVEL_SOURCE_TYPES source_type);
+
+/**************************************************************************//**
+ * Map an ::EVEL_VF_STATUSES enum value to the equivalent string.
+ *
+ * @param vf_status     The vf_status to convert.
+ * @returns The equivalent string.
+ *****************************************************************************/
+char * evel_vf_status(const EVEL_VF_STATUSES vf_status);
+
+/**************************************************************************//**
+ * Convert a ::EVEL_ENTITY_STATE to it's string form for JSON encoding.
+ *
+ * @param state         The entity state to encode.
+ *
+ * @returns the corresponding string
+ *****************************************************************************/
+char * evel_entity_state(const EVEL_ENTITY_STATE state);
+
+/**************************************************************************//**
+ * Convert a ::EVEL_SERVICE_ENDPOINT_DESC to string form for JSON encoding.
+ *
+ * @param endpoint_desc endpoint description to encode.
+ *
+ * @returns the corresponding string
+ *****************************************************************************/
+char * evel_service_endpoint_desc(const EVEL_ENTITY_STATE endpoint_desc);
+
+
+/**************************************************************************//**
+ * Initialize an ::EVEL_OPTION_INTHEADER_FIELDS to a not-set state.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_INTHEADER_FIELDS.
+ *****************************************************************************/
+void evel_init_option_intheader(EVEL_OPTION_INTHEADER_FIELDS * const option);
+/**************************************************************************//**
+ * Force the value of an ::EVEL_OPTION_INTHEADER_FIELDS.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_INTHEADER_FIELDS.
+ * @param value         The value to set.
+ *****************************************************************************/
+void evel_force_option_intheader(EVEL_OPTION_INTHEADER_FIELDS * const option,
+                           const void* value);
+/**************************************************************************//**
+ * Set the value of an ::EVEL_OPTION_INTHEADER_FIELDS.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_INTHEADER_FIELDS.
+ * @param value         The value to set.
+ * @param description   Description to be used in logging.
+ *****************************************************************************/
+void evel_set_option_intheader(EVEL_OPTION_INTHEADER_FIELDS * const option,
+                         const void * value,
+                         const char * const description);
+/**************************************************************************//**
+ * Free the underlying resources of an ::EVEL_OPTION_INTHEADER_FIELDS.
+ *
+ * @param option        Pointer to the ::EVEL_OPTION_INTHEADER_FIELDS.
+ *****************************************************************************/
+void evel_free_option_intheader(EVEL_OPTION_INTHEADER_FIELDS * const option);
+
+#endif
diff --git a/src/plugins/ves/include/evel_throttle.h b/src/plugins/ves/include/evel_throttle.h
new file mode 100644
index 00000000..c97b3c37
--- /dev/null
+++ b/src/plugins/ves/include/evel_throttle.h
@@ -0,0 +1,214 @@
+/*************************************************************************//**
+ *
+ * Copyright © 2017 AT&T Intellectual Property. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ *
+ ****************************************************************************/
+/**************************************************************************//**
+ * @file
+ * EVEL throttle definitions.
+ *
+ * These are internal definitions related to throttling specicications, which
+ * are required within the library but are not intended for external
+ * consumption.
+ *
+ ****************************************************************************/
+
+#ifndef EVEL_THROTTLE_INCLUDED
+#define EVEL_THROTTLE_INCLUDED
+
+#include "evel_internal.h"
+#include "jsmn.h"
+
+/*****************************************************************************/
+/* Maximum depth of JSON response that we can handle.                        */
+/*****************************************************************************/
+#define EVEL_JSON_STACK_DEPTH           10
+
+/**************************************************************************//**
+ * Maximum number of tokens that we allow for in a JSON response.
+ *****************************************************************************/
+#define EVEL_MAX_RESPONSE_TOKENS        1024
+
+/**************************************************************************//**
+ * The nature of the next token that we are iterating through.  Within an
+ * object, we alternate between collecting keys and values.  Within an array,
+ * we only collect items.
+ *****************************************************************************/
+typedef enum {
+  EVEL_JSON_KEY,
+  EVEL_JSON_VALUE,
+  EVEL_JSON_ITEM
+} EVEL_JSON_STATE;
+
+/**************************************************************************//**
+ * States which we move through during JSON processing, tracking our way
+ * through the supported JSON structure.
+ *****************************************************************************/
+typedef enum
+{
+  /***************************************************************************/
+  /* Initial state.                                                          */
+  /***************************************************************************/
+  EVEL_JCS_START,
+
+  /***************************************************************************/
+  /* {"commandList": [                                                       */
+  /***************************************************************************/
+  EVEL_JCS_COMMAND_LIST,
+
+  /***************************************************************************/
+  /* {"commandList": [{                                                      */
+  /***************************************************************************/
+  EVEL_JCS_COMMAND_LIST_ENTRY,
+
+  /***************************************************************************/
+  /* {"commandList": [{"command": {                                          */
+  /***************************************************************************/
+  EVEL_JCS_COMMAND,
+
+  /***************************************************************************/
+  /* ... "eventDomainThrottleSpecification": {                               */
+  /***************************************************************************/
+  EVEL_JCS_SPEC,
+
+  /***************************************************************************/
+  /* ... "suppressedFieldNames": [                                           */
+  /***************************************************************************/
+  EVEL_JCS_FIELD_NAMES,
+
+  /***************************************************************************/
+  /* ... "suppressedNvPairsList": [                                          */
+  /***************************************************************************/
+  EVEL_JCS_PAIRS_LIST,
+
+  /***************************************************************************/
+  /* ... "suppressedNvPairsList": [{                                         */
+  /***************************************************************************/
+  EVEL_JCS_PAIRS_LIST_ENTRY,
+
+  /***************************************************************************/
+  /* ... "suppressedNvPairNames": [                                          */
+  /***************************************************************************/
+  EVEL_JCS_NV_PAIR_NAMES,
+
+  EVEL_JCS_MAX
+} EVEL_JSON_COMMAND_STATE;
+
+/**************************************************************************//**
+ * An entry in the JSON stack.
+ *****************************************************************************/
+typedef struct evel_json_stack_entry {
+
+  /***************************************************************************/
+  /* The number of elements required at this level.                          */
+  /***************************************************************************/
+  int num_required;
+
+  /***************************************************************************/
+  /* The number of elements collected at this level.                         */
+  /***************************************************************************/
+  int json_count;
+
+  /***************************************************************************/
+  /* The collection state at this level in the JSON stack.                   */
+  /***************************************************************************/
+  EVEL_JSON_STATE json_state;
+
+  /***************************************************************************/
+  /* The key being collected (if json_state is EVEL_JSON_VALUE), or NULL.    */
+  /***************************************************************************/
+  char * json_key;
+
+} EVEL_JSON_STACK_ENTRY;
+
+/**************************************************************************//**
+ * The JSON stack.
+ *****************************************************************************/
+typedef struct evel_json_stack {
+
+  /***************************************************************************/
+  /* The current position of the stack - starting at zero.                   */
+  /***************************************************************************/
+  int level;
+
+  /***************************************************************************/
+  /* The stack itself.                                                       */
+  /***************************************************************************/
+  EVEL_JSON_STACK_ENTRY entry[EVEL_JSON_STACK_DEPTH];
+
+  /***************************************************************************/
+  /* The underlying memory chunk.                                            */
+  /***************************************************************************/
+  const MEMORY_CHUNK * chunk;
+
+} EVEL_JSON_STACK;
+
+/**************************************************************************//**
+ * Initialize event throttling to the default state.
+ *
+ * Called from ::evel_initialize.
+ *****************************************************************************/
+void evel_throttle_initialize();
+
+/**************************************************************************//**
+ * Clean up event throttling.
+ *
+ * Called from ::evel_terminate.
+ *****************************************************************************/
+void evel_throttle_terminate();
+
+/**************************************************************************//**
+ * Handle a JSON response from the listener, as a list of tokens from JSMN.
+ *
+ * @param chunk         Memory chunk containing the JSON buffer.
+ * @param json_tokens   Array of tokens to handle.
+ * @param num_tokens    The number of tokens to handle.
+ * @param post          The memory chunk in which to place any resulting POST.
+ * @return true if the command was handled, false otherwise.
+ *****************************************************************************/
+bool evel_handle_command_list(const MEMORY_CHUNK * const chunk,
+                              const jsmntok_t * const json_tokens,
+                              const int num_tokens,
+                              MEMORY_CHUNK * const post);
+
+/**************************************************************************//**
+ * Return the ::EVEL_THROTTLE_SPEC for a given domain.
+ *
+ * @param domain        The domain for which to return state.
+ *****************************************************************************/
+EVEL_THROTTLE_SPEC * evel_get_throttle_spec(EVEL_EVENT_DOMAINS domain);
+
+/**************************************************************************//**
+ * Determine whether a field_name should be suppressed.
+ *
+ * @param throttle_spec Throttle specification for the domain being encoded.
+ * @param field_name    The field name to encoded or suppress.
+ * @return true if the field_name should be suppressed, false otherwise.
+ *****************************************************************************/
+bool evel_throttle_suppress_field(EVEL_THROTTLE_SPEC * throttle_spec,
+                                  const char * const field_name);
+
+/**************************************************************************//**
+ * Determine whether a name-value pair should be allowed (not suppressed).
+ *
+ * @param throttle_spec Throttle specification for the domain being encoded.
+ * @param field_name    The field name holding the name-value pairs.
+ * @param name          The name of the name-value pair to encoded or suppress.
+ * @return true if the name-value pair should be suppressed, false otherwise.
+ *****************************************************************************/
+bool evel_throttle_suppress_nv_pair(EVEL_THROTTLE_SPEC * throttle_spec,
+                                    const char * const field_name,
+                                    const char * const name);
+
+#endif
diff --git a/src/plugins/ves/include/hashtable.h b/src/plugins/ves/include/hashtable.h
new file mode 100644
index 00000000..8be17dc1
--- /dev/null
+++ b/src/plugins/ves/include/hashtable.h
@@ -0,0 +1,97 @@
+#ifndef HASHTABLE_INCLUDED
+#define HASHTABLE_INCLUDED
+
+/*************************************************************************//**
+ *
+ * Copyright © 2017 AT&T Intellectual Property. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+/**************************************************************************//**
+ * @file
+ * A simple hashtable.
+ *
+ * @note  No thread protection so you will need to use appropriate
+ * synchronization if use spans multiple threads.
+*****************************************************************************/
+
+typedef struct entry_s {
+	char *key;
+	void *value;
+	struct entry_s *next;
+} ENTRY_T;
+
+/**************************************************************************//**
+ * Hashtable structure
+ *****************************************************************************/
+
+typedef struct hashtable_s {
+	size_t size;
+	struct entry_s **table;	
+} HASHTABLE_T;
+
+/**************************************************************************//**
+ * Hashtable initialization.
+ *
+ * Initialize the list supplied to be empty.
+ *
+ * @param   size  Size of hashtable
+
+ * @returns Hashtable pointer
+******************************************************************************/
+/* Create a new hashtable. */
+HASHTABLE_T *ht_create( size_t size );
+
+/**************************************************************************//**
+ * Hash a string for a particular hash table.
+ *
+ * Initialize the list supplied to be empty.
+ *
+ * @param   hashtable    Pointer to the hashtable
+ * @param   key          String
+
+ * @returns hashvalue
+******************************************************************************/
+size_t ht_hash( HASHTABLE_T *hashtable, char *key );
+
+/**************************************************************************//**
+ * Create a key-value pair.
+ *
+ * @param   key     key string
+ * @param   value   value string
+ *
+ * @returns hashtable entry
+******************************************************************************/
+ENTRY_T *ht_newpair( char *key, void *value );
+
+/**************************************************************************//**
+ * Insert a key-value pair into a hash table.
+ *
+ * @param   key     key string
+ * @param   value   value string
+ *
+ * @returns Nothing
+******************************************************************************/
+void ht_set( HASHTABLE_T *hashtable, char *key, void *value );
+
+/**************************************************************************//**
+ *  Retrieve a key-value pair from a hash table.
+ *
+ * @param   key     key string
+ *
+ * @returns  value string
+******************************************************************************/
+void *ht_get( HASHTABLE_T *hashtable, char *key );
+
+#endif
diff --git a/src/plugins/ves/include/jsmn.h b/src/plugins/ves/include/jsmn.h
new file mode 100644
index 00000000..4ae6d9b4
--- /dev/null
+++ b/src/plugins/ves/include/jsmn.h
@@ -0,0 +1,93 @@
+/*************************************************************************//**
+ *
+ * Copyright © 2017 AT&T Intellectual Property. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+#ifndef __JSMN_H_
+#define __JSMN_H_
+
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * JSON type identifier. Basic types are:
+ * 	o Object
+ * 	o Array
+ * 	o String
+ * 	o Other primitive: number, boolean (true/false) or null
+ */
+typedef enum {
+	JSMN_UNDEFINED = 0,
+	JSMN_OBJECT = 1,
+	JSMN_ARRAY = 2,
+	JSMN_STRING = 3,
+	JSMN_PRIMITIVE = 4
+} jsmntype_t;
+
+enum jsmnerr {
+	/* Not enough tokens were provided */
+	JSMN_ERROR_NOMEM = -1,
+	/* Invalid character inside JSON string */
+	JSMN_ERROR_INVAL = -2,
+	/* The string is not a full JSON packet, more bytes expected */
+	JSMN_ERROR_PART = -3
+};
+
+/**
+ * JSON token description.
+ * @param		type	type (object, array, string etc.)
+ * @param		start	start position in JSON data string
+ * @param		end		end position in JSON data string
+ */
+typedef struct {
+	jsmntype_t type;
+	int start;
+	int end;
+	int size;
+#ifdef JSMN_PARENT_LINKS
+	int parent;
+#endif
+} jsmntok_t;
+
+/**
+ * JSON parser. Contains an array of token blocks available. Also stores
+ * the string being parsed now and current position in that string
+ */
+typedef struct {
+	unsigned int pos; /* offset in the JSON string */
+	unsigned int toknext; /* next token to allocate */
+	int toksuper; /* superior token node, e.g parent object or array */
+} jsmn_parser;
+
+/**
+ * Create JSON parser over an array of tokens
+ */
+void jsmn_init(jsmn_parser *parser);
+
+/**
+ * Run JSON parser. It parses a JSON data string into and array of tokens, each describing
+ * a single JSON object.
+ */
+int jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
+		jsmntok_t *tokens, unsigned int num_tokens);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __JSMN_H_ */
diff --git a/src/plugins/ves/include/metadata.h b/src/plugins/ves/include/metadata.h
new file mode 100644
index 00000000..1ee44092
--- /dev/null
+++ b/src/plugins/ves/include/metadata.h
@@ -0,0 +1,58 @@
+#ifndef METADATA_INCLUDED
+#define METADATA_INCLUDED
+/*************************************************************************//**
+ *
+ * Copyright © 2017 AT&T Intellectual Property. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+/**************************************************************************//**
+ * @file
+ * Wrap the OpenStack metadata service.
+ *
+ ****************************************************************************/
+
+#include "evel.h"
+
+/**************************************************************************//**
+ * Download metadata from the OpenStack metadata service.
+ *
+ * @param verbosity   Controls whether to generate debug to stdout.  Zero:
+ *                    none.  Non-zero: generate debug.
+ * @returns Status code
+ * @retval  EVEL_SUCCESS      On success
+ * @retval  ::EVEL_ERR_CODES  On failure.
+ *****************************************************************************/
+EVEL_ERR_CODES openstack_metadata(int verbosity);
+
+/**************************************************************************//**
+ * Initialize default values for vm_name and vm_uuid - for testing purposes.
+ *****************************************************************************/
+void openstack_metadata_initialize();
+
+/**************************************************************************//**
+ * Get the VM name provided by the metadata service.
+ *
+ * @returns VM name
+ *****************************************************************************/
+const char *openstack_vm_name();
+
+/**************************************************************************//**
+ * Get the VM UUID provided by the metadata service.
+ *
+ * @returns VM UUID
+ *****************************************************************************/
+const char *openstack_vm_uuid();
+
+#endif
diff --git a/src/plugins/ves/include/ring_buffer.h b/src/plugins/ves/include/ring_buffer.h
new file mode 100644
index 00000000..1236b78b
--- /dev/null
+++ b/src/plugins/ves/include/ring_buffer.h
@@ -0,0 +1,96 @@
+/*************************************************************************//**
+ *
+ * Copyright © 2017 AT&T Intellectual Property. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+#ifndef RING_BUFFER_INCLUDED
+#define RING_BUFFER_INCLUDED
+
+/**************************************************************************//**
+ * @file
+ * Ring  buffer to handle message requests.
+ *
+ ****************************************************************************/
+
+#include <pthread.h>
+
+/**************************************************************************//**
+ * Ring buffer structure.
+ *****************************************************************************/
+typedef struct ring_buffer
+{
+    int size;
+    int next_write;
+    int next_read;
+    void ** ring;
+    pthread_cond_t ring_cv;
+    pthread_mutex_t ring_mutex;
+} ring_buffer;
+
+/**************************************************************************//**
+ * Ring buffer initialization.
+ *
+ * Initialize the buffer supplied to the specified size.
+ *
+ * @param   buffer  Pointer to the ring-buffer to be initialized.
+ * @param   size    How many elements to be stored in the ring-buffer.
+ *
+ * @returns Nothing
+******************************************************************************/
+void ring_buffer_initialize(ring_buffer * buffer, int size);
+
+/**************************************************************************//**
+ * Read an element from a ring_buffer.
+ *
+ * Reads an element from the ring_buffer, advancing the next-read position.
+ * Operation is synchronized and therefore MT-safe.  Blocks if no data is
+ * available.
+ *
+ * @param   buffer  Pointer to the ring-buffer to be read.
+ *
+ * @returns Pointer to the element read from the buffer.
+******************************************************************************/
+void * ring_buffer_read(ring_buffer * buffer);
+
+/**************************************************************************//**
+ * Write an element into a ring_buffer.
+ *
+ * Writes an element into the ring_buffer, advancing the next-write position.
+ * Operation is synchronized and therefore MT-safe.  Fails if the buffer is
+ * full without blocking.
+ *
+ * @param   buffer  Pointer to the ring-buffer to be written.
+ * @param   msg     Pointer to data to be stored in the ring_buffer.
+ *
+ * @returns Number of items written.
+ * @retval  1       The data was written successfully.
+ * @retval  0       The ring_buffer was full so no data written.
+******************************************************************************/
+int ring_buffer_write(ring_buffer * buffer, void * msg);
+
+/**************************************************************************//**
+ * Tests whether there is data in the ring_buffer.
+ *
+ * Tests whether there is currently data in the ring_buffer without blocking.
+ *
+ * @param   buffer  Pointer to the ring-buffer to be tested.
+ *
+ * @returns Whether there is data in the ring_buffer.
+ * @retval  0       There isn't any data in the ring_buffer.
+ * @retval  1       There is data in the ring_buffer.
+******************************************************************************/
+int ring_buffer_is_empty(ring_buffer * buffer);
+
+#endif
diff --git a/src/plugins/ves/ves.api b/src/plugins/ves/ves.api
new file mode 100644
index 00000000..a7106f8d
--- /dev/null
+++ b/src/plugins/ves/ves.api
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2017 Intel and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** \brief VES Agent config add / del request
+    @param client_index - opaque cookie to identify the sender
+    @param context - sender context, to match reply w/ request
+    @param server_port - VES Server port
+    @param read_interval - Time period for each loop
+    @param is_add - add the config if non-zero, else delete
+    @param server_addr[] - server address
+*/
+define ves_agent_config
+{
+  u32 client_index;
+  u32 context;
+  u32 server_port;
+  u32 read_interval;
+  u32 is_add;
+  u8 server_addr[16];
+};
+
+/** \brief VES Agent config response
+    @param context - sender context, to match reply w/ request
+    @param retval - return code for the request
+*/
+define ves_agent_config_reply
+{
+  u32 context;
+  i32 retval;
+};
+
+/** \brief VES Agent mode set request
+    @param client_index - opaque cookie to identify the sender
+    @param context - sender context, to match reply w/ request
+    @param pkt_loss_rate - Base packet loss rate if Demo Mode
+    @param work_mode[] - Agent's work mode, real or demo
+*/
+define ves_agent_mode
+{
+  u32 client_index;
+  u32 context;
+  u32 pkt_loss_rate;
+  u8  work_mode[8];
+};
+
+/** \brief VES Agent Mode response
+    @param context - sender context, to match reply w/ request
+    @param retval - return code for the request
+*/
+define ves_agent_mode_reply
+{
+  u32 context;
+  i32 retval;
+};
+
+/*
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/ves/ves_all_api_h.h b/src/plugins/ves/ves_all_api_h.h
new file mode 100644
index 00000000..72b15697
--- /dev/null
+++ b/src/plugins/ves/ves_all_api_h.h
@@ -0,0 +1,18 @@
+/*
+ * ves_all_api_h.h - skeleton vpp engine plug-in api #include file
+ *
+ * Copyright (c) 2017 Intel and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <ves/ves.api.h>
diff --git a/src/plugins/ves/ves_api.c b/src/plugins/ves/ves_api.c
new file mode 100644
index 00000000..7a9b8004
--- /dev/null
+++ b/src/plugins/ves/ves_api.c
@@ -0,0 +1,139 @@
+/*
+ *------------------------------------------------------------------
+ * ves_api.c - ves api
+ *
+ * Copyright (c) 2017 Intel and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *------------------------------------------------------------------
+ */
+
+#include <vnet/vnet.h>
+#include <vlibmemory/api.h>
+
+#include <vnet/interface.h>
+#include <vnet/api_errno.h>
+#include <vnet/ip/ip.h>
+#include <vnet/ip/ip4.h>
+
+#include <ves/ves_node.h>
+
+#include <ves/ves_msg_enum.h> /* define message IDs */
+
+#define vl_typedefs		/* define message structures */
+#include <ves/ves_all_api_h.h>
+#undef vl_typedefs
+
+#define vl_endianfun		/* define message structures */
+#include <ves/ves_all_api_h.h>
+#undef vl_endianfun
+
+/* instantiate all the print functions we know about */
+#define vl_print(handle, ...) vlib_cli_output (handle, __VA_ARGS__)
+
+#define vl_printfun
+#include <ves/ves_all_api_h.h>
+#undef vl_printfun
+
+
+#include <vlibapi/api_helper_macros.h>
+
+#define foreach_vpe_api_msg                       \
+_(VES_AGENT_CONFIG,ves_agent_config)            \
+_(VES_AGENT_MODE,ves_agent_mode)
+
+static void vl_api_ves_agent_config_t_handler
+  (vl_api_ves_agent_config_t *mp)
+{
+  vl_api_ves_agent_config_reply_t *rmp;
+  ip46_address_t server;
+  int rv = -1;
+
+  ip46_address_reset (&server);
+  clib_memcpy (&server.ip4, mp->server_addr, sizeof (server.ip4));
+
+  rv = ves_set_server(&server,
+		      (u32) ntohl (mp->server_port),
+		      (u32) ntohl (mp->read_interval),
+		      (int) (mp->is_add == 0));
+
+  REPLY_MACRO (VL_API_VES_AGENT_CONFIG_REPLY);
+}
+
+static void vl_api_ves_agent_mode_t_handler
+  (vl_api_ves_agent_mode_t *mp)
+{
+  vl_api_ves_agent_mode_reply_t *rmp;
+  ves_agent_mode_t mode = VES_AGENT_MODE_REAL;
+  int rv = -1;
+
+  if (!strcmp((char *)mp->work_mode, "demo")
+      || !strcmp((char *)mp->work_mode, "Demo")
+      || !strcmp((char *)mp->work_mode, "DEMO"))
+    mode = VES_AGENT_MODE_DEMO;
+
+  rv = ves_agent_set_mode(mode, (u32) ntohl(mp->pkt_loss_rate));
+
+  REPLY_MACRO (VL_API_VES_AGENT_MODE_REPLY);
+}
+
+/*
+ * ves_api_hookup
+ * Add vpe's API message handlers to the table.
+ * vlib has alread mapped shared memory and
+ * added the client registration handlers.
+ * See .../vlib-api/vlibmemory/memclnt_vlib.c:memclnt_process()
+ */
+#define vl_msg_name_crc_list
+#include <ves/ves_all_api_h.h>
+#undef vl_msg_name_crc_list
+
+static void
+setup_message_id_table (api_main_t * am)
+{
+#define _(id,n,crc) vl_msg_api_add_msg_name_crc (am, #n "_" #crc, id);
+  foreach_vl_msg_name_crc_ves;
+#undef _
+}
+
+static clib_error_t *
+ves_api_hookup (vlib_main_t * vm)
+{
+  api_main_t *am = &api_main;
+
+#define _(N,n)                                                  \
+    vl_msg_api_set_handlers(VL_API_##N, #n,                     \
+                           vl_api_##n##_t_handler,              \
+                           vl_noop_handler,                     \
+                           vl_api_##n##_t_endian,               \
+                           vl_api_##n##_t_print,                \
+                           sizeof(vl_api_##n##_t), 1);
+  foreach_vpe_api_msg;
+#undef _
+
+  /*
+   * Set up the (msg_name, crc, message-id) table
+   */
+  setup_message_id_table (am);
+
+  return 0;
+}
+
+VLIB_API_INIT_FUNCTION (ves_api_hookup);
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/ves/ves_msg_enum.h b/src/plugins/ves/ves_msg_enum.h
new file mode 100644
index 00000000..6e8a5dfa
--- /dev/null
+++ b/src/plugins/ves/ves_msg_enum.h
@@ -0,0 +1,31 @@
+/*
+ * ves_msg_enum.h - vpp engine plug-in message enumeration
+ *
+ * Copyright (c) 2017 Intel and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef _VES_MSG_ENUM_H_
+#define _VES_MSG_ENUM_H_
+
+#include <vppinfra/byte_order.h>
+
+#define vl_msg_id(n,h) n,
+typedef enum
+{
+#include <ves/ves_all_api_h.h>
+  /* We'll want to know how many messages IDs we need... */
+  VL_MSG_FIRST_AVAILABLE,
+} vl_msg_id_t;
+#undef vl_msg_id
+
+#endif /* _VES_MSG_ENUM_H_ */
diff --git a/src/plugins/ves/ves_node.c b/src/plugins/ves/ves_node.c
new file mode 100644
index 00000000..7540dd16
--- /dev/null
+++ b/src/plugins/ves/ves_node.c
@@ -0,0 +1,646 @@
+/*
+ * Copyright (c) 2017 Intel and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/time.h>
+
+#include <vnet/plugin/plugin.h>
+#include <vpp/app/version.h>
+
+#include "ves_node.h"
+
+#define BUFSIZE 128
+
+typedef struct dummy_vpp_metrics_struct {
+  int bytes_in;
+  int bytes_out;
+  int packets_in;
+  int packets_out;
+} vpp_metrics_struct;
+
+static vlib_node_registration_t ves_agent_process_node;
+vpp_metrics_struct *last_vpp_metrics;
+vpp_metrics_struct *curr_vpp_metrics;
+time_t start_epoch;
+time_t last_epoch;
+char hostname[BUFSIZE];
+
+static u8 *format_ves_agent_config(u8 *s, va_list *args);
+
+void read_vpp_metrics(vpp_metrics_struct *vpp_metrics, char *vnic) {
+  // Define an array of char that contains the parameters of the unix 'cut' command
+  char* params[] = {"-f3", "-f11", "-f4", "-f12"};
+  // Define the unix command to execute in order to read metrics from the vNIC
+  char* cmd_prefix = "sudo cat /proc/net/dev | grep \"";
+  char* cmd_mid = "\" | tr -s \' \' | cut -d\' \' ";
+  char cmd[BUFSIZE];
+  // Define other variables
+  char buf[BUFSIZE];		/* buffer used to store VPP metrics 	*/
+  int temp[] = {0, 0, 0, 0};	/* temp array that contains VPP values 	*/
+  FILE *fp;			/* file descriptor to pipe cmd to shell */
+  int i;
+
+  for(i = 0; i < 4; i++) {
+    // Clear buffers
+    memset(buf, 0, BUFSIZE);
+    memset(cmd, 0, BUFSIZE);
+    // Build shell command to read metrics from the vNIC
+    strcat(cmd, cmd_prefix);
+    strcat(cmd, vnic);
+    strcat(cmd, cmd_mid);
+    strcat(cmd, params[i]);
+    
+    // Open a pipe and read VPP values
+    if ((fp = popen(cmd, "r")) == NULL) {
+        printf("Error opening pipe!\n");
+        return;
+    }
+
+    while (fgets(buf, BUFSIZE, fp) != NULL);
+    temp[i] = atoi(buf);
+
+    if(pclose(fp))  {
+        printf("Command not found or exited with error status\n");
+        return;
+    }
+  }
+
+  // Store metrics read from the vNIC in the struct passed from the main function
+  vpp_metrics->bytes_in = temp[0];
+  vpp_metrics->bytes_out = temp[1];
+  vpp_metrics->packets_in = temp[2];
+  vpp_metrics->packets_out = temp[3];
+}
+
+/**************************************************************************//**
+ * tap live cpu stats
+ *****************************************************************************/
+void evel_get_cpu_stats(EVENT_MEASUREMENT * measurement)
+{
+  FILE *fp;
+  char path[1024];
+  double usage=0.0;
+  double idle;
+  double intrpt;
+  double nice;
+  double softirq;
+  double steal;
+  double sys;
+  double user;
+  double wait;
+  MEASUREMENT_CPU_USE *cpu_use = NULL;
+
+  /* Open the command for reading. */
+  //fp = popen("/bin/ls /etc/", "r");
+  fp = popen("/usr/bin/top -bn 2 -d 0.01 | grep '^%Cpu' | tail -n 1 ", "r");
+  if (fp == NULL) {
+    printf("Failed to run command\n" );
+    exit(1);
+  }
+
+  /* Read the output a line at a time - output it. */
+  while (fgets(path, sizeof(path)-1, fp) != NULL) {
+    printf("%s", path+10);
+    sscanf(path+10," %lf us, %lf sy,  %lf ni,  %lf id,  %lf wa,  %lf hi,  %lf si,  %lf st",
+    &user,&sys,&nice,&idle,&wait,&intrpt,&softirq,&steal);
+  }
+
+  /* close */
+  pclose(fp);
+
+  cpu_use = evel_measurement_new_cpu_use_add(measurement, "cpu1", usage);
+  if( cpu_use != NULL ){
+  evel_measurement_cpu_use_idle_set(cpu_use,idle);
+  //evel_measurement_cpu_use_interrupt_set(cpu_use,intrpt);
+  //evel_measurement_cpu_use_nice_set(cpu_use,nice);
+  //evel_measurement_cpu_use_softirq_set(cpu_use,softirq);
+  //evel_measurement_cpu_use_steal_set(cpu_use,steal);
+  evel_measurement_cpu_use_system_set(cpu_use,sys);
+  evel_measurement_cpu_use_usageuser_set(cpu_use,user);
+  //evel_measurement_cpu_use_wait_set(cpu_use,wait);
+  //evel_measurement_cpu_use_add(measurement, "cpu2", usage,idle,intrpt,nice,softirq,steal,sys,user,wait);
+  }
+}
+
+int
+ves_agent_report_vnic_stats(ves_agent_main_t *vam)
+{
+	EVEL_ERR_CODES evel_rc = EVEL_SUCCESS;
+	EVENT_MEASUREMENT* vpp_m = NULL;
+	EVENT_HEADER* vpp_m_header = NULL;
+	int bytes_in_this_round;
+	int bytes_out_this_round;
+	int packets_in_this_round;
+	int packets_out_this_round;
+	struct timeval time_val;
+
+	/* Is not enabled, do nothing */
+	if (vam->config.is_enabled == VES_AGENT_DISABLED) {
+		return 0;
+	}
+
+	memset(curr_vpp_metrics, 0, sizeof(vpp_metrics_struct));
+	read_vpp_metrics(curr_vpp_metrics, DEFAULT_MEASURE_ETH);
+
+	if(curr_vpp_metrics->bytes_in - last_vpp_metrics->bytes_in > 0) {
+		bytes_in_this_round = curr_vpp_metrics->bytes_in - last_vpp_metrics->bytes_in;
+	} else {
+		bytes_in_this_round = 0;
+	}
+
+	if(curr_vpp_metrics->bytes_out - last_vpp_metrics->bytes_out > 0) {
+		bytes_out_this_round = curr_vpp_metrics->bytes_out - last_vpp_metrics->bytes_out;
+	} else {
+		bytes_out_this_round = 0;
+	}
+
+	if(curr_vpp_metrics->packets_in - last_vpp_metrics->packets_in > 0) {
+		packets_in_this_round = curr_vpp_metrics->packets_in - last_vpp_metrics->packets_in;
+	} else {
+		packets_in_this_round = 0;
+	}
+
+	if(curr_vpp_metrics->packets_out - last_vpp_metrics->packets_out > 0) {
+		packets_out_this_round = curr_vpp_metrics->packets_out - last_vpp_metrics->packets_out;
+	} else {
+		packets_out_this_round = 0;
+	}
+
+	vpp_m = evel_new_measurement(vam->config.read_interval, "Measurement_vGMUX", "Generic_traffic");
+	if(vpp_m != NULL) {
+          char str_pkt_loss[12];
+          MEASUREMENT_VNIC_PERFORMANCE * vnic_performance = NULL;
+
+	  printf("New measurement report created...\n");
+
+          vnic_performance = (MEASUREMENT_VNIC_PERFORMANCE *)evel_measurement_new_vnic_performance(
+                               DEFAULT_MEASURE_ETH, "true");
+          evel_meas_vnic_performance_add(vpp_m, vnic_performance);
+          evel_measurement_type_set(vpp_m, "HTTP request rate");
+          evel_measurement_request_rate_set(vpp_m, rand()%10000);
+
+          evel_vnic_performance_rx_total_pkt_delta_set(vnic_performance, packets_in_this_round);
+          evel_vnic_performance_tx_total_pkt_delta_set(vnic_performance, packets_out_this_round);
+
+          evel_vnic_performance_rx_octets_delta_set(vnic_performance, bytes_in_this_round);
+          evel_vnic_performance_tx_octets_delta_set(vnic_performance, bytes_out_this_round);
+          evel_get_cpu_stats(vpp_m);
+
+#if 0
+	  evel_measurement_vnic_use_add(vpp_m,		/* Pointer to the measurement      */ 
+  			  DEFAULT_MEASURE_ETH, 		/* ASCII string with the vNIC's ID */
+	                packets_in_this_round, 		/* Packets received      	   */
+	               packets_out_this_round,		/* Packets transmitted   	   */
+	                                    0,		/* Broadcast packets received      */
+	                                    0,		/* Broadcast packets transmitted   */
+		          bytes_in_this_round,		/* Total bytes received            */
+		         bytes_out_this_round, 		/* Total bytes transmitted         */
+			                    0, 		/* Multicast packets received      */
+				            0, 		/* Multicast packets transmitted   */
+				            0, 		/* Unicast packets received        */
+	  				    0);		/* Unicast packets transmitted     */
+#endif
+
+	 sprintf(str_pkt_loss, "%.1f %%", (double) vam->config.base_pkt_loss);
+         evel_measurement_custom_measurement_add(vpp_m,          /* Pointer to the measurement      */
+                                           "ONAP-DCAE",          /* measurement group's name        */
+                                    "Packet-Loss-Rate",          /* the measurement's name          */
+                                          str_pkt_loss);         /* The measurement's value         */
+
+      last_epoch = start_epoch + vam->config.read_interval * 1000000;
+      vpp_m_header = (EVENT_HEADER *)vpp_m;
+      vpp_m_header->start_epoch_microsec = start_epoch;
+      vpp_m_header->last_epoch_microsec = last_epoch;
+      strcpy(vpp_m_header->reporting_entity_id.value, "No UUID available");
+      strcpy(vpp_m_header->reporting_entity_name, hostname);
+
+      evel_rc = evel_post_event(vpp_m_header);
+      if(evel_rc == EVEL_SUCCESS) {
+        printf("Measurement report correctly sent to the collector!\n");
+      }
+      else {
+        printf("Post failed %d (%s)\n", evel_rc, evel_error_string());
+      }
+    }
+    else {
+      printf("New measurement report failed (%s)\n", evel_error_string());
+    }
+
+	last_vpp_metrics->bytes_in = curr_vpp_metrics->bytes_in;
+	last_vpp_metrics->bytes_out = curr_vpp_metrics->bytes_out;
+	last_vpp_metrics->packets_in = curr_vpp_metrics->packets_in;
+	last_vpp_metrics->packets_out = curr_vpp_metrics->packets_out;
+	gettimeofday(&time_val, NULL);
+	start_epoch = time_val.tv_sec * 1000000 + time_val.tv_usec;
+
+	return 0;
+}
+
+always_inline int
+ves_agent_start(ves_agent_main_t *vam)
+{
+	vlib_main_t *vm = vam->vlib_main;
+	struct timeval time_val;
+	char fqdn[16]; /* "xxx.xxx.xxx.xxx" */
+	//char *fqdn = "127.0.0.1"; /* "xxx.xxx.xxx.xxx" */
+
+        sprintf(fqdn, "%d.%d.%d.%d", vam->config.server_addr.data[0],
+		vam->config.server_addr.data[1],
+		vam->config.server_addr.data[2],
+		vam->config.server_addr.data[3]);
+	/* Always success. TODO: Error check in next version */
+  	last_vpp_metrics = malloc(sizeof(vpp_metrics_struct));
+  	curr_vpp_metrics = malloc(sizeof(vpp_metrics_struct));
+
+	if(evel_initialize(fqdn,                         /* FQDN                  */
+	vam->config.server_port, 	                 /* Port                  */
+	                   NULL,                         /* optional path         */
+	                   NULL,                         /* optional topic        */
+	                   0,                            /* HTTPS?                */
+	                   "",                           /* Username              */
+	                   "",                           /* Password              */
+	                   EVEL_SOURCE_VIRTUAL_MACHINE,  /* Source type           */
+	                   "vG-MUX",      	         /* Role                  */
+	                   1))                           /* Verbosity             */
+	{
+		fprintf(stderr, "\nFailed to initialize the EVEL library!!!\n");
+		return -1;
+	}
+
+	gethostname(hostname, BUFSIZE);
+	memset(last_vpp_metrics, 0, sizeof(vpp_metrics_struct));
+	read_vpp_metrics(last_vpp_metrics, DEFAULT_MEASURE_ETH);
+	gettimeofday(&time_val, NULL);
+	start_epoch = time_val.tv_sec * 1000000 + time_val.tv_usec;
+
+	vlib_process_wait_for_event_or_clock(vm, (f64)(vam->config.read_interval));
+
+	return 0;
+}
+
+always_inline int
+ves_agent_stop(void)
+{
+	sleep(1);
+	free(last_vpp_metrics);
+	free(curr_vpp_metrics);
+	evel_terminate();
+
+	return 0;
+}
+
+/* *INDENT-OFF* */
+VLIB_PLUGIN_REGISTER () = {
+	.version = VPP_BUILD_VER,
+	.description = "VNF Event Stream Agent",
+};
+/* *INDENT-ON* */
+
+static uword
+ves_agent_process (vlib_main_t * vm,
+                   vlib_node_runtime_t * rt,
+                   vlib_frame_t * f)
+{
+	ves_agent_main_t *vam = &ves_agent_main;
+	uword event_type;
+	uword * event_data = 0;
+
+	if (vam->config.read_interval == 0) {
+		vam->config.read_interval = DEFAULT_READ_INTERVAL;
+	}
+
+	while (1)
+	{
+		vlib_process_wait_for_event_or_clock(vm, (f64)(vam->config.read_interval));
+
+		event_type = vlib_process_get_events (vm, &event_data);
+
+		switch (event_type)
+		{
+		case EVENT_VES_AGENT_START:
+			ves_agent_start(vam);
+			break;
+		case EVENT_VES_AGENT_STOP:
+			ves_agent_stop();
+			break;
+		default:
+			ves_agent_report_vnic_stats(vam);
+			break;
+		}
+
+		vec_reset_length (event_data);
+	}
+
+	/* NOTREACHED */
+	return 0;
+}
+
+VLIB_REGISTER_NODE (ves_agent_process_node, static) = {
+	.function = ves_agent_process,
+	.type = VLIB_NODE_TYPE_PROCESS,
+	.name = "ves-agent-process",
+	.process_log2_n_stack_bytes = 16,
+};
+
+int
+ves_set_server (ip46_address_t *addr,
+                u32 server_port,
+                u32 read_interval, 
+                int is_del)
+{
+	ves_agent_main_t *vam = &ves_agent_main;
+	vlib_main_t *vm = vam->vlib_main;
+	int rc = 0;
+
+	if (ip46_address_is_zero(addr))
+		return VNET_API_ERROR_INVALID_DST_ADDRESS;
+  
+	if (is_del)
+	{
+		if (vam->config.is_enabled == VES_AGENT_DISABLED) {
+			return rc;
+		}
+
+		if ((vam->config.server_addr.as_u32 != addr->ip4.as_u32)
+		    || (vam->config.server_port != server_port))
+			return VNET_API_ERROR_NO_SUCH_ENTRY;
+
+		memset(&(vam->config.server_addr), 0, sizeof(ip4_address_t));
+		vam->config.server_port = DEFAULT_SERVER_PORT;
+		vam->config.read_interval = DEFAULT_READ_INTERVAL;
+		vam->config.is_enabled = VES_AGENT_DISABLED;
+		vlib_process_signal_event (vm, ves_agent_process_node.index,
+					   EVENT_VES_AGENT_STOP, 0);
+	} else {
+		// Already enabled the same config.
+		if ((vam->config.server_addr.as_u32 == addr->ip4.as_u32)
+		    && (vam->config.server_port != server_port)
+		    && vam->config.read_interval == read_interval
+	            && vam->config.is_enabled == VES_AGENT_ENABLED) {
+			return rc;
+		}
+
+		// Already enabled, but not exact match.
+		if (vam->config.is_enabled == VES_AGENT_ENABLED) {
+	              	return VNET_API_ERROR_VALUE_EXIST;
+		}
+
+		vam->config.server_addr.as_u32 = addr->ip4.as_u32;
+		vam->config.server_port = server_port;
+		if (read_interval) {
+			vam->config.read_interval = read_interval;
+		} else {
+			vam->config.read_interval = DEFAULT_READ_INTERVAL;
+		}
+		vam->config.is_enabled = VES_AGENT_ENABLED;
+		vlib_process_signal_event (vm, ves_agent_process_node.index,
+					   EVENT_VES_AGENT_START, 0);
+	}
+
+	return (rc);
+}
+
+static u8 *
+format_ves_agent_set_error(u8 *s, va_list *args)
+{
+	s = format(s, "%s\n\n", "Caution, set fails due to enabled config:");
+	s = format(s, "%U", format_ves_agent_config, NULL);
+	return s;
+}
+
+static clib_error_t *
+ves_server_set_command_fn(vlib_main_t * vm,
+                          unformat_input_t * input,
+                          vlib_cli_command_t * cmd)
+{
+	ip46_address_t server_addr;
+	u32 server_port = DEFAULT_SERVER_PORT, inter_val = DEFAULT_READ_INTERVAL;
+	int is_del = 0, set_server = 0;
+
+	memset(&server_addr, 0, sizeof(server_addr));
+
+	while (unformat_check_input(input) != UNFORMAT_END_OF_INPUT) 
+	{
+		if (unformat (input, "server %U", 
+		    unformat_ip4_address, &server_addr.ip4))
+			set_server = 1;
+		else if (unformat (input, "port %u", &server_port))
+			;
+		else if (unformat (input, "intval %u", &inter_val))
+			;
+      		else if (unformat (input, "delete") ||
+		    unformat (input, "del"))
+			is_del = 1;
+		else
+			break;
+	}
+
+	if (is_del || set_server)
+	{
+		int rv;
+
+		rv = ves_set_server (&server_addr, server_port, inter_val, is_del);
+		switch (rv)
+		{
+			case 0:
+				return 0;
+
+			case VNET_API_ERROR_INVALID_DST_ADDRESS:
+				return clib_error_return (0, "Invalid address");
+          
+			case VNET_API_ERROR_NO_SUCH_ENTRY:
+				return clib_error_return(0, "No such Entry found");
+
+			case VNET_API_ERROR_VALUE_EXIST:
+				vlib_cli_output (vm, "%U\n", format_ves_agent_set_error, NULL);
+				return clib_error_return (0, "BUG found!");
+
+			default:
+				return clib_error_return (0, "BUG: rv %d", rv);
+		}
+	} else {
+		return clib_error_return (0, "parse error`%U'",
+			    format_unformat_error, input);
+	}
+}
+
+VLIB_CLI_COMMAND (ves_server_set_command, static) = {
+	.path = "set ves agent",
+	.short_help = "set ves agent [del] server <ipaddr> port <port> [intval <inter-value>]",
+	.function = ves_server_set_command_fn,
+};
+
+static u8 *
+format_ves_agent_config(u8 *s, va_list *args)
+{
+	ves_agent_main_t *vam = &ves_agent_main;
+	char fqdn[16]; /* "xxx.xxx.xxx.xxx" */
+
+	s = format(s, "%=16s %=12s %=8s %s\n", "Server Addr",
+		   "Server Port", "Interval", "Enabled");
+	if (vam->config.is_enabled == VES_AGENT_DISABLED) {
+		return s;
+	}
+
+        sprintf(fqdn, "%d.%d.%d.%d", vam->config.server_addr.data[0],
+		vam->config.server_addr.data[1],
+		vam->config.server_addr.data[2],
+		vam->config.server_addr.data[3]);
+
+	s = format(s, "%=16s %=12d  %=8d %s\n", fqdn,
+		vam->config.server_port,
+		vam->config.read_interval,
+		vam->config.is_enabled ? "True" : "False");
+
+	return s;
+}
+
+static clib_error_t *
+ves_server_show_command_fn(vlib_main_t * vm,
+                           unformat_input_t * input,
+                           vlib_cli_command_t * cmd)
+{
+	vlib_cli_output (vm, "%U", format_ves_agent_config, NULL);
+
+	return (NULL);
+}
+
+VLIB_CLI_COMMAND (ves_server_show_command, static) = {
+	.path = "show ves agent",
+	.short_help = "Display VES Agent Configuration",
+	.function = ves_server_show_command_fn,
+};
+
+int
+ves_agent_set_mode(ves_agent_mode_t mode,
+                   u32 pkt_loss_rate)
+{
+	ves_agent_main_t *vam = &ves_agent_main;
+	int retval = 0;
+
+	if (VES_AGENT_MODE_DEMO == mode) {
+		if (pkt_loss_rate > 100) {
+			vam->config.mode = VES_AGENT_MODE_REAL;
+			vam->config.base_pkt_loss = 0;
+			return 1;
+		}
+		vam->config.mode = VES_AGENT_MODE_DEMO;
+		vam->config.base_pkt_loss = pkt_loss_rate;
+	} else { /* Only demo or real for current stage */
+		vam->config.mode = VES_AGENT_MODE_REAL;
+		vam->config.base_pkt_loss = 0;
+	}
+
+	return retval;
+}
+
+static clib_error_t *
+ves_mode_set_command_fn(vlib_main_t * vm,
+                        unformat_input_t * input,
+                        vlib_cli_command_t * cmd)
+{
+	u32 pkt_loss_rate = 0;
+	ves_agent_mode_t mode = VES_AGENT_MODE_REAL;
+        int set_mode = 0;
+
+	while (unformat_check_input(input) != UNFORMAT_END_OF_INPUT) 
+	{
+      		if (unformat (input, "demo") || unformat (input, "Demo") 
+		    || unformat (input, "DEMO"))
+                {
+			mode = VES_AGENT_MODE_DEMO;
+			set_mode = 1;
+                }
+      		else if (unformat (input, "real") || unformat (input, "Real") 
+		    || unformat (input, "REAL"))
+			set_mode = 1;
+		else if (unformat (input, "base %u", &pkt_loss_rate))
+			;
+		else
+			break;
+	}
+
+	if (set_mode)
+	{
+		int retval = ves_agent_set_mode(mode, pkt_loss_rate);
+		if (retval == 0)
+			return 0;
+		else
+			return clib_error_return (0, "BUG found!");
+	} else {
+		return clib_error_return (0, "parse error`%U'",
+			    format_unformat_error, input);
+	}
+}
+
+VLIB_CLI_COMMAND (ves_mode_set_command, static) = {
+	.path = "set ves mode",
+	.short_help = "set ves mode <demo|real> [base <pkt-loss-rate>]",
+	.function = ves_mode_set_command_fn,
+};
+
+static inline u8 *
+format_ves_agent_mode(u8 *s, va_list *args)
+{
+	ves_agent_main_t *vam = &ves_agent_main;
+
+	s = format(s, "%=8s %s\n", "Mode", "Base Packet Loss Rate");
+
+	s = format(s, "%=8s         %.1f %%\n",
+		vam->config.mode ==  VES_AGENT_MODE_DEMO ? "Demo" : "Real",
+		(double) vam->config.base_pkt_loss);
+
+	return s;
+}
+
+static clib_error_t *
+ves_agent_mode_show_command_fn(vlib_main_t * vm,
+                               unformat_input_t * input,
+                               vlib_cli_command_t * cmd)
+{
+	vlib_cli_output (vm, "%U", format_ves_agent_mode, NULL);
+
+	return (NULL);
+}
+
+VLIB_CLI_COMMAND (ves_agent_mode_show_command, static) = {
+	.path = "show ves mode",
+	.short_help = "Display VES Agent Mode Information",
+	.function = ves_agent_mode_show_command_fn,
+};
+
+static clib_error_t *
+ves_agent_init(vlib_main_t * vm)
+{
+	ves_agent_main_t *vam = &ves_agent_main;
+
+	vam->vlib_main = vm;
+	vam->vnet_main = vnet_get_main();
+
+	return 0;
+}
+
+VLIB_INIT_FUNCTION (ves_agent_init);
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/ves/ves_node.h b/src/plugins/ves/ves_node.h
new file mode 100644
index 00000000..7b773843
--- /dev/null
+++ b/src/plugins/ves/ves_node.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2017 Intel and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _VES_NODE_H_
+#define _VES_NODE_H_
+
+#include <vnet/ip/ip.h>
+
+#include "include/evel.h"
+
+#define DEFAULT_SERVER_IP	"127.0.0.1"
+#define DEFAULT_MEASURE_ETH	"eth0"
+#define DEFAULT_SERVER_PORT	8080
+#define DEFAULT_READ_INTERVAL	100
+
+typedef enum {
+	VES_AGENT_MODE_REAL = 0,
+	VES_AGENT_MODE_DEMO,
+	_NUM_VES_AGENT_MODES
+} ves_agent_mode_t;
+
+/* VES Agent Server configuration */
+typedef struct {
+	ip4_address_t		server_addr;
+	u32			server_port;
+	u32			read_interval;
+	int			is_enabled;
+	u32			base_pkt_loss; /* For demo only */
+	ves_agent_mode_t	mode; /* Demo or Real */
+} ves_agent_config_t;
+
+typedef struct {
+	ves_agent_config_t config;
+
+	/* convenience */
+	vlib_main_t * vlib_main;
+	vnet_main_t * vnet_main;
+} ves_agent_main_t;
+
+ves_agent_main_t ves_agent_main;
+
+#define EVENT_VES_AGENT_START 	1
+#define EVENT_VES_AGENT_STOP	0
+
+#define VES_AGENT_DISABLED	0
+#define VES_AGENT_ENABLED	1
+
+int ves_set_server(ip46_address_t *addr, u32 server_port,
+		   u32 read_interval, int is_del);
+
+int ves_agent_set_mode(ves_agent_mode_t mode,
+                       u32 pkt_loss_rate);
+
+#endif /* _VES_NODE_H_ */
diff --git a/src/vpp-api/java/Makefile.am b/src/vpp-api/java/Makefile.am
index f18e0c24..7f4738d8 100644
--- a/src/vpp-api/java/Makefile.am
+++ b/src/vpp-api/java/Makefile.am
@@ -148,6 +148,26 @@ jvpp-snat/io_fd_vpp_jvpp_snat_JVppSnatImpl.h: $(jvpp_registry_ok) $(jvpp_snat_js
 	$(call japigen,snat,JVppSnatImpl)
 endif
 
+#
+# VES Plugin
+#
+if ENABLE_VES_PLUGIN
+noinst_LTLIBRARIES += libjvpp_ves.la
+libjvpp_ves_la_SOURCES = jvpp-ves/jvpp_ves.c
+libjvpp_ves_la_CPPFLAGS = -Ijvpp-ves
+libjvpp_ves_la_LIBADD = $(JVPP_LIBS)
+libjvpp_ves_la_DEPENDENCIES = libjvpp_common.la
+
+BUILT_SOURCES += jvpp-ves/io_fd_vpp_jvpp_ves_JVppVesImpl.h
+JAR_FILES += jvpp-ves-$(PACKAGE_VERSION).jar
+CLEANDIRS += jvpp-ves/target
+
+jvpp_ves_json_files = @top_builddir@/plugins/ves/ves.api.json
+
+jvpp-ves/io_fd_vpp_jvpp_ves_JVppVesImpl.h: $(jvpp_registry_ok) $(jvpp_ves_json_files)
+	$(call japigen,ves,JVppVesImpl)
+endif
+
 #
 # iOAM Trace Plugin
 #
diff --git a/src/vpp-api/java/jvpp-ves/jvpp_ves.c b/src/vpp-api/java/jvpp-ves/jvpp_ves.c
new file mode 100644
index 00000000..60e325b5
--- /dev/null
+++ b/src/vpp-api/java/jvpp-ves/jvpp_ves.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2017 Intel Corp and/or its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <vnet/vnet.h>
+
+#include <ves/ves_msg_enum.h>
+#define vl_typedefs             /* define message structures */
+#include <ves/ves_all_api_h.h>
+#undef vl_typedefs
+
+#include <vnet/api_errno.h>
+#include <vlibapi/api.h>
+#include <vlibmemory/api.h>
+
+#if VPPJNI_DEBUG == 1
+  #define DEBUG_LOG(...) clib_warning(__VA_ARGS__)
+#else
+  #define DEBUG_LOG(...)
+#endif
+
+#include <jvpp-common/jvpp_common.h>
+
+#include "jvpp-ves/io_fd_vpp_jvpp_ves_JVppVesImpl.h"
+#include "jvpp_ves.h"
+#include "jvpp-ves/jvpp_ves_gen.h"
+
+/*
+ * Class:     io_fd_vpp_jvpp_ves_JVppVesImpl
+ * Method:    init0
+ * Signature: (JI)V
+ */
+JNIEXPORT void JNICALL Java_io_fd_vpp_jvpp_ves_JVppVesImpl_init0
+  (JNIEnv *env, jclass clazz, jobject callback, jlong queue_address, jint my_client_index) {
+  ves_main_t * plugin_main = &ves_main;
+  clib_warning ("Java_io_fd_vpp_jvpp_ves_JVppVesImpl_init0");
+
+  plugin_main->my_client_index = my_client_index;
+  plugin_main->vl_input_queue = (unix_shared_memory_queue_t *)queue_address;
+
+  plugin_main->callbackObject = (*env)->NewGlobalRef(env, callback);
+  plugin_main->callbackClass = (jclass)(*env)->NewGlobalRef(env, (*env)->GetObjectClass(env, callback));
+
+  // verify API has not changed since jar generation
+  #define _(N)             \
+      get_message_id(env, #N);
+      foreach_supported_api_message;
+  #undef _
+
+  #define _(N,n)                                  \
+      vl_msg_api_set_handlers(get_message_id(env, #N), #n,     \
+              vl_api_##n##_t_handler,             \
+              vl_noop_handler,                    \
+              vl_noop_handler,                    \
+              vl_noop_handler,                    \
+              sizeof(vl_api_##n##_t), 1);
+      foreach_api_reply_handler;
+  #undef _
+}
+
+JNIEXPORT void JNICALL Java_io_fd_vpp_jvpp_ves_JVppVesImpl_close0
+(JNIEnv *env, jclass clazz) {
+  ves_main_t * plugin_main = &ves_main;
+
+    // cleanup:
+    (*env)->DeleteGlobalRef(env, plugin_main->callbackClass);
+    (*env)->DeleteGlobalRef(env, plugin_main->callbackObject);
+
+    plugin_main->callbackClass = NULL;
+    plugin_main->callbackObject = NULL;
+}
+
+/* Attach thread to JVM and cache class references when initiating JVPP VES */
+jint JNI_OnLoad(JavaVM *vm, void *reserved) {
+    JNIEnv* env;
+
+    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_8) != JNI_OK) {
+        return JNI_EVERSION;
+    }
+
+    if (cache_class_references(env) != 0) {
+        clib_warning ("Failed to cache class references\n");
+        return JNI_ERR;
+    }
+
+    return JNI_VERSION_1_8;
+}
+
+/* Clean up cached references when disposing JVPP VES */
+void JNI_OnUnload(JavaVM *vm, void *reserved) {
+    JNIEnv* env;
+    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_8) != JNI_OK) {
+        return;
+    }
+    delete_class_references(env);
+}
diff --git a/src/vpp-api/java/jvpp-ves/jvpp_ves.h b/src/vpp-api/java/jvpp-ves/jvpp_ves.h
new file mode 100644
index 00000000..642101ca
--- /dev/null
+++ b/src/vpp-api/java/jvpp-ves/jvpp_ves.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2017 Intel Corp and/or its affiliates.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef __included_jvpp_ves_h__
+#define __included_jvpp_ves_h__
+
+#include <vnet/vnet.h>
+#include <vnet/ip/ip.h>
+#include <vnet/api_errno.h>
+#include <vlibapi/api.h>
+#include <vlibmemory/api.h>
+#include <jni.h>
+
+/* Global state for JVPP-VES */
+typedef struct {
+    /* Pointer to shared memory queue */
+    unix_shared_memory_queue_t * vl_input_queue;
+
+    /* VPP api client index */
+    u32 my_client_index;
+
+    /* Callback object and class references enabling asynchronous Java calls */
+    jobject callbackObject;
+    jclass callbackClass;
+
+} ves_main_t;
+
+ves_main_t ves_main __attribute__((aligned (64)));
+
+
+#endif /* __included_jvpp_ves_h__ */
-- 
2.14.1.windows.1

